* Java 基础教程
** 基本语法
编写 Java 程序时，应注意以下几点：
大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。
类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass。
方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。
主方法入口：所有的 Java 程序由 public static void main(String []args)方法开始执行。
** Java 标识符
Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。
关于 Java 标识符，有以下几点需要注意：
所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
首字符之后可以是任何字符的组合
关键字不能用作标识符
标识符是大小写敏感的
合法标识符举例：age、$salary、_value、__1_value
非法标识符举例：123abc、-salary
** Java 修饰符
像其他语言一样，Java 可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：
可访问修饰符 : default, public , protected, private
不可访问修饰符 : final, abstract, strictfp
在后面的章节中我们会深入讨论 Java 修饰符。
** Java 变量
Java 中主要有如下几种类型的变量
局部变量
类变量（静态变量）
成员变量（非静态变量）
** Java 关键字
下面列出了 Java 保留字。这些保留字不能用于常量、变量、和任何标识符的名称。
关键字	描述
abstract	抽象方法，抽象类的修饰符
assert	断言条件是否满足
boolean	布尔数据类型
break	跳出循环或者 label 代码段
byte	8-bit 有符号数据类型
case	switch 语句的一个条件
catch	和 try 搭配扑捉异常信息
char	16-bit Unicode 字符数据类型
class	定义类
const	未使用
continue	不执行循环体剩余部分
default	switch 语句中的默认分支
do	循环语句，循环体至少会执行一次
double	64-bit 双精度浮点数
else	if 条件不成立时执行的分支
enum	枚举类型
extends	表示一个类是另一个类的子类
final	表示一个值在初始化之后就不能再改变了
表示方法不能被重写，或者一个类不能有子类
finally	为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。
float	32-bit 单精度浮点数
for	for 循环语句
goto	未使用
if	条件语句
implements	表示一个类实现了接口
import	导入类
instanceof	测试一个对象是否是某个类的实例
int	32 位整型数
interface	接口，一种抽象的类型，仅有方法和常量的定义
long	64 位整型数
native	表示方法用非 java 代码实现
new	分配新的类实例
package	一系列相关类组成一个包
private	表示私有字段，或者方法等，只能从类内部访问
protected	表示字段只能通过类或者其子类访问
子类或者在同一个包内的其他类
public	表示共有属性或者方法
return	方法返回值
short	16 位数字
static	表示在类级别定义，所有实例共享的
strictfp	浮点数比较使用严格的规则
super	表示基类
switch	选择语句
synchronized	表示同一时间只能由一个线程访问的代码块
this	表示调用当前实例
或者调用另一个构造函数
throw	抛出异常
throws	定义方法可能抛出的异常
transient	修饰不要序列化的字段
try	表示代码块要做异常处理或者和 finally 配合表示是否抛出异常都执行 finally 中的代码
void	标记方法不返回任何值
volatile	标记字段可能会被多个线程同时访问，而不做同步
while	while 循环
** 面向对象
Java 作为一种面向对象语言。支持以下基本概念：
多态
继承
封装
抽象
类
对象
实例
方法
重载
对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
类：类是一个模板，它描述一类对象的行为和状态。

** Class
public class Dog{
   String breed;
   int age;
   String color;
   void barking(){
   }
   
   void hungry(){
   }
   
   void sleeping(){
   }
}
一个类可以包含以下类型变量：
局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。
** 源文件声明规则
在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则。
一个源文件中只能有一个 public 类
一个源文件可以有多个非 public 类
源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为 Employee.java。
如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。
如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。
类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。
除了上面提到的几种类型，Java 还有一些特殊的类，如：内部类、匿名类。
** Java 数据类型
byte
short
int
long
float
double
boolean
char 16 位 unicode 字符
引用类型：
在 Java 中，引用类型的变量非常类似于 C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Pubby 等。变量一旦声明后，类型就不能被改变了。
对象、数组都是引用数据类型。
所有引用类型的默认值都是 null。
一个引用变量可以用来引用与任何与之兼容的类型。
例子：Site site = new Site("Runoob")。
- 常量
  final 声明常量,虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。
  final int test = 10;
- 字符串
  双引号包含
  "Hello World"
  "two\nlines"
  "\"This is in quotes\""
  字符串常量和字符常量都可以包含任何 Unicode 字符。例如：
  char a = '\u0001';
  String a = "\u0001";
- Java 转义序列
  Java 语言支持一些特殊的转义字符序列。
  符号	字符含义
  \n	换行 (0x0a)
  \r	回车 (0x0d)
  \f	换页符(0x0c)
  \b	退格 (0x08)
  \s	空格 (0x20)
  \t	制表符
  \"	双引号
  \'	单引号
  \\	反斜杠
  \ddd	八进制字符 (ddd)
  \uxxxx	16 进制 Unicode 字符 (xxxx)
** Java 变量类型
在 Java 语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：
type identifier [ = value][, identifier [= value] ...] ;
String nihao = "你好"
*** Java 局部变量
局部变量声明在方法、构造方法或者语句块中；
局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
访问修饰符不能用于局部变量；
局部变量只在声明它的方法、构造方法或者语句块中可见；
局部变量是在栈上分配的。
局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。
*** 实例变量
实例变量声明在一个类中，但在方法、构造方法和语句块之外；
当一个对象被实例化之后，每个实例变量的值就跟着确定；
实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
实例变量可以声明在使用前或者使用后；
访问修饰符可以修饰实例变量；
实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；
*** 类变量（静态变量）
实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。
类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。
无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。
静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。
静态变量在程序开始时创建，在程序结束时销毁。
与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
静态变量可以通过：ClassName.VariableName 的方式访问。
类变量被声明为 public static final 类型时，类变量名称必须使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。
** Java 修饰符
Java 语言提供了很多修饰符，主要分为以下两类：
*** 访问修饰符
修饰符用来定义类、方法或者变量，通常放在语句的最前端
**** 访问控制修饰符
  Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。
  默认的，也称为 default，在同一包内可见，不使用任何修饰符。
  私有的，以 private 修饰符指定，在同一类内可见。
  共有的，以 public 修饰符指定，对所有类可见。
  受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。
**** 默认访问修饰符-不使用任何关键字
  使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。
**** 私有访问修饰符-private
  有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。
  声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。
  Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。
**** 公有访问修饰符-public
  被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。
  如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。
  Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。
**** 受保护的访问修饰符-protected
  被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。
  Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected。
  子类能访问 Protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。
**** 访问控制和继承
  请注意以下方法继承的规则：
  父类中声明为 public 的方法在子类中也必须为 public。
  父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。不能声明为 private。
  父类中声明为 private 的方法，不能够被继承。
*** 非访问修饰符
为了实现一些其他的功能，Java 也提供了许多非访问修饰符。
static 修饰符，用来创建类方法和类变量。
Final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
Abstract 修饰符，用来创建抽象类和抽象方法。
Synchronized 和 volatile 修饰符，主要用于线程的编程。
**** Static 修饰符
- 静态变量：
  Static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被成为类变量。局部变量不能被声明为 static 变量。
- 静态方法：
  Static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。
  对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。
**** Final 修饰符
- Final 变量：
  Final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。
  Final 修饰符通常和 static 修饰符一起使用来创建类常量。
- Final 方法
  类中的 Final 方法可以被子类继承，但是不能被子类修改。
  声明 final 方法的主要目的是防止该方法的内容被修改。
- Final 类
  Final 类不能被继承，没有类能够继承 final 类的任何特性。
**** Abstract 修饰符
- 抽象类：
  抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。
  一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。
  抽象类可以包含抽象方法和非抽象方法。
- 抽象方法
  抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 strict。
  任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。
  如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。
  抽象方法的声明以分号结尾，例如：public abstract sample();
**** Synchronized 修饰符
Synchronized 关键字声明的方法同一时间只能被一个线程访问。Synchronized 修饰符可以应用于四个访问修饰符。
**** Transient 修饰符
序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。
该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。
**** Volatile 修饰符
Volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
一个 volatile 对象引用可能是 null。
** Java 运算符
*** 算术运算符
算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。
表格中的实例假设整数变量 A 的值为 10，变量 B 的值为 20：
操作符	描述	例子
+	加法 - 相加运算符两侧的值	A + B 等于 30
-	减法 - 左操作数减去右操作数	A – B 等于-10
*	乘法 - 相乘操作符两侧的值	A * B 等于 200
/	除法 - 左操作数除以右操作数	B / A 等于 2
％	取模 - 左操作数除右操作数的余数	B%A 等于 0
+ +	自增 - 操作数的值增加 1	B + +等于 21
--	自减 -- 操作数的值减少 1	B - -等于 19
*** 关系运算符
下表为 Java 支持的关系运算符
表格中的实例整数变量 A 的值为 10，变量 B 的值为 20：
运算符	描述	例子
==	检查如果两个操作数的值是否相等，如果相等则条件为真。	（A == B）为假(非真)。
!=	检查如果两个操作数的值是否相等，如果值不相等则条件为真。	(A != B) 为真。
> 	检查左操作数的值是否大于右操作数的值，如果是那么条件为真。	（A> B）非真。
< 	检查左操作数的值是否小于右操作数的值，如果是那么条件为真。	（A <B）为真。
> =	检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。	（A> = B）为假。
<=	检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。	（A <= B）为真。
*** 位运算符
Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。
下表列出了位运算符的基本运算,假设整数变量 A 的值为 60 和变量 B 的值为 13：
操作符	描述	例子
＆	按位与操作符，当且仅当两个操作数的某一位都非 0 时候结果的该位才为 1。	（A＆B），得到 12，即 0000 1100
\|	按位或操作符，只要两个操作数的某一位有一个非 0 时候结果的该位就为 1。	（A | B）得到 61，即 0011 1101
^	按位异或操作符，两个操作数的某一位不相同时候结果的该位就为 1。	（A ^ B）得到 49，即 0011 0001
〜	按位补运算符翻转操作数的每一位。	（〜A）得到-61，即 1100 0011
<< 	按位左移运算符。左操作数按位左移右操作数指定的位数。	A << 2 得到 240，即 1111 0000
>> 	按位右移运算符。左操作数按位右移右操作数指定的位数。	A >> 2 得到 15 即 1111
>>> 	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。	A>>>2 得到 15 即 0000 1111
*** 逻辑运算符
下表列出了逻辑运算符的基本运算，假设布尔变量 A 为真，变量 B 为假
操作符	描述	例子
&&	称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。	（A && B）为假。
\| |	称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。	（A | | B）为真。
！	称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为 true，则逻辑非运算符将得到 false。	！（A && B）为真。
*** 赋值运算符
下面是 Java 语言支持的赋值运算符：
操作符	描述	例子
=	简单的赋值运算符，将右操作数的值赋给左侧操作数	C = A + B 将把 A + B 得到的值赋给 C
+ =	加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数	C + = A 等价于 C = C + A
- =	减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数	C - = A 等价于 C = C -
 A
\* =	乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数	C * = A 等价于 C = C * A
/ =	除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数	C / = A 等价于 C = C / A
（％）=	取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数	C％= A 等价于 C = C％A
<< =	左移位赋值运算符	C << = 2 等价于 C = C << 2
>> =	右移位赋值运算符	C >> = 2 等价于 C = C >> 2
＆=	按位与赋值运算符	C＆= 2 等价于 C = C＆2
^ =	按位异或赋值操作符	C ^ = 2 等价于 C = C ^ 2
\| =	按位或赋值操作符	C | = 2 等价于 C = C | 2
*** 条件运算符（?:）
条件运算符也被称为三元运算符。该运算符有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。
*** instanceOf 运算符
该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。
instanceof 运算符使用格式如下：
( Object reference variable ) instanceOf  (class/interface type)
*** Java 运算符优先级
当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。
例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。
再如，x = 7 + 3 * 2;这里 x 得到 13，而不是 20，因为乘法运算符比加法运算符有较高的优先级，所以先计算 3 * 2 得到 6，然后再加 7。
下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。
类别	操作符	关联性
后缀	() [] . (点操作符)	左到右
一元	+ + - ！〜	从右到左
乘性 	* /％	左到右
加性 	+ -	左到右
移位 	>> >>>  << 	左到右
关系 	>> = << = 	左到右
相等 	==  !=	左到右
按位与	＆	左到右
按位异或	^	左到右
按位或	|	左到右
逻辑与	&&	左到右
逻辑或	| |	左到右
条件	？：	从右到左
赋值	= + = - = * = / =％= >> = << =＆= ^ = | =	从右到左
逗号	，	左到右
** Java 循环结构 - for, while 及 do...while
顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。
Java 中有三种主要的循环结构：
while 循环
do…while 循环
for 循环
*** while 循环
while 是最基本的循环，它的结构为：
while( 布尔表达式 ) {
	//循环内容
}
*** do…while 循环
对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。
do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。
do {
       //代码语句
}while(布尔表达式);
注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。
*** for 循环
虽然所有循环结构都可以用 while 或者 do...while 表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。
for 循环执行的次数是在执行前就确定的。语法格式如下：
for(初始化; 布尔表达式; 更新) {
    //代码语句
}
关于 for 循环有以下几点说明：
最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。
然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。
执行一次循环后，更新循环控制变量。
再次检测布尔表达式。循环执行上面的过程。
*** Java 增强 for 循环
Java5 引入了一种主要用于数组的增强型 for 循环。
Java 增强 for 循环语法格式如下:
for(声明语句 : 表达式)
{
   //代码句子
}
声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
表达式：表达式是要访问的数组名，或者是返回值为数组的方法。
*** break 关键字
break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。
break 跳出最里层的循环，并且继续执行该循环下面的语句。
语法
break 的用法很简单，就是循环结构中的一条语句：
*** continue 关键字
continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。
在 for 循环中，continue 语句使程序立即跳转到更新语句。
在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。
语法
continue 就是循环体中一条简单的语句：
** Java 分支结构 - if...else/switch
顺序结构只能顺序执行，不能进行判断和选择，因此需要分支结构。
Java 有两种分支结构：
if 语句
switch 语句
*** if 语句
一个 if 语句包含一个布尔表达式和一条或多条语句。
语法
If 语句的用语法如下：
if(布尔表达式)
{
   //如果布尔表达式为 true 将执行的语句
}
*** if...else 语句
if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。
语法
if…else 的用法如下：
if(布尔表达式){
   //如果布尔表达式的值为 true
}else{
   //如果布尔表达式的值为 false
}
*** if...else if...else 语句
if 语句后面可以跟 elseif…else 语句，这种语句可以检测到多种可能的情况。
使用 if，else if，else 语句的时候，需要注意下面几点：
- if 语句至多有 1 个 else 语句，else 语句在所有的 elseif 语句之后。
- If 语句可以有若干个 elseif 语句，它们必须在 else 语句之前。
- 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。
语法
  if...else 语法格式如下:
  if(布尔表达式 1){
    //如果布尔表达式 1 的值为 true 执行代码
  }else if(布尔表达式 2){
    //如果布尔表达式 2 的值为 true 执行代码
  }else if(布尔表达式 3){
    //如果布尔表达式 3 的值为 true 执行代码
  }else {
    //如果以上布尔表达式都不为 true 执行代码
  }

*** 嵌套的 if…else 语句
  使用嵌套的 if-else 语句是合法的。也就是说你可以在另一个 if 或者 elseif 语句中使用 if 或者 elseif 语句。
*** switch 语句
switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。
语法
switch 语法格式如下：
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的 case 语句
    default : //可选
       //语句
}
switch 语句有如下规则：
switch 语句中的变量类型只能为 byte、short、int 或者 char。
switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。
case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。
当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。3
当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。
switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。
** Java Number 类
一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。
实例
int a = 5000;
float b = 13.65;
byte c = 0x4a;
然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。
所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。
Java Number 类
这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。
下面是一个使用 Integer 对象的实例：
public class Test{

   public static void main(String args[]){
      Integer x = 5;
      x =  x + 10;
      System.out.println(x); 
   }
}
以上实例编译运行结果如下：
15
当 x 被赋为整型值时，由于 x 是一个对象，所以编译器要对 x 进行装箱。然后，为了使 x 能进行加运算，所以要对 x 进行拆箱。
Number 方法
下面的表中列出的是 Number 子类实现的方法：
序号	方法与描述
1	xxxValue() 将 number 对象转换为 xxx 数据类型的值并返回。
2	compareTo() 将 number 对象与参数比较。
3	equals() 判断 number 对象是否与参数相等。
4	valueOf() 返回一个 Number 对象指定的内置数据类型
5	toString() 以字符串形式返回值。
6	parseInt() 将字符串解析为 int 类型。
7	abs() 返回参数的绝对值。
8	ceil() 对整形变量向左取整，返回类型为 double 型。
9	floor() 对整型变量向右取整。返回类型为 double 类型。
10	rint() 返回与参数最接近的整数。返回类型为 double。
11	round() 返回一个最接近的 int、long 型值。
12	min() 返回两个参数中的最小值。
13	max() 返回两个参数中的最大值。
14	exp() 返回自然数底数 e 的参数次方。
15	log() 返回参数的自然数底数的对数值。
16	pow() 返回第一个参数的第二个参数次方。
17	sqrt() 求参数的算术平方根。
18	sin() 求指定 double 类型参数的正弦值。
19	cos() 求指定 double 类型参数的余弦值。
20	tan() 求指定 double 类型参数的正切值。
21	asin() 求指定 double 类型参数的反正弦值。
22	acos() 求指定 double 类型参数的反余弦值。
23	atan() 求指定 double 类型参数的反正切值。
24	atan2() 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。
25	toDegrees() 将参数转化为角度。
26	toRadians() 将角度转换为弧度。
27	random() 返回一个随机数。
** Java Character 类
Character 类用于对单个字符进行操作。
Character 类在对象中包装一个基本类型 char 的值
实例
char ch = 'a';

// Unicode 字符表示形式
char uniChar = '\u039A'; 

// 字符数组
char[] charArray ={ 'a', 'b', 'c', 'd', 'e' }; 
然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java 语言为内置数据类型 char 提供了包装类 Character 类。
Character 类提供了一系列方法来操纵字符。你可以使用 Character 的构造方法创建一个 Character 类对象，例如：
Character ch = new Character('a');
在某些情况下，Java 编译器会自动创建一个 Character 对象。
例如，将一个 char 类型的参数传递给需要一个 Character 类型参数的方法时，那么编译器会自动地将 char 类型参数转换为 Character 对象。 这种特征称为装箱，反过来称为拆箱。
实例
// 原始字符 'a' 装箱到 Character 对象 ch 中
Character ch = 'a';

// 原始字符 'x' 用 test 方法装箱
// 返回拆箱的值到 'c'
char c = test('x');
转义序列
前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。
下面列表展示了 Java 的转义序列：
转义序列	描述
\t	在文中该处插入一个 tab 键
\b	在文中该处插入一个后退键
\n	在文中该处换行
\r	在文中该处插入回车
\f	在文中该处插入换页符
\'	在文中该处插入单引号
\"	在文中该处插入双引号
\\	在文中该处插入反斜杠
实例
当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。
以下实例转义双引号并输出：
public class Test {

   public static void main(String args[]) {
      System.out.println("访问\"菜鸟教程!\"");
   }
}
以上实例编译运行结果如下：
访问"菜鸟教程!"
Character 方法
下面是 Character 类的方法：
序号	方法与描述
1	isLetter() 是否是一个字母
2	isDigit() 是否是一个数字字符
3	isWhitespace() 是否一个空格
4	isUpperCase() 是否是大写字母
5	isLowerCase() 是否是小写字母
6	toUpperCase() 指定字母的大写形式
7	toLowerCase() 指定字母的小写形式
8	toString() 返回字符的字符串形式，字符串的长度仅为 1
对于方法的完整列表，请参考的 java.lang.Character API 规范。
** Java String 类
字符串广泛应用在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。
创建字符串
创建字符串最简单的方式如下:
String greeting = "Hello world!";
在代码中遇到字符串常量时，这里的值是"Hello world!"，编译器会使用该值创建一个 String 对象。
和其它对象一样，可以使用关键字和构造方法来创建 String 对象。
String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:
public class StringDemo{

   public static void main(String args[]){
      char[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.'};
      String helloString = new String(helloArray);  
      System.out.println( helloString );
   }
}
以上实例编译运行结果如下：
hello.
注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer & StringBuilder 类。
字符串长度
用于获取有关对象的信息的方法称为访问器方法。
String 类的一个访问器方法是 length()方法，它返回字符串对象包含的字符数。
下面的代码执行后，len 变量等于 14:
public class StringDemo {
    public static void main(String args[]) {
        String site = "www.runoob.com";
        int len = site.length();
        System.out.println( "菜鸟教程网址长度 : " + len );
   }
}
以上实例编译运行结果如下：
菜鸟教程网址长度 : 14
连接字符串
String 类提供了连接两个字符串的方法：
string1.concat(string2);
返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat()方法，如：
"My name is ".concat("Runoob");
更常用的是使用'+'操作符来连接字符串，如：
"Hello," + " world" + "!"
结果如下:
"Hello, world!"
下面是一个例子:
public class StringDemo {
    public static void main(String args[]) {     
        String string1 = "菜鸟教程网址：";     
        System.out.println("1、" + string1 + "www.runoob.com");  
    }
}
以上实例编译运行结果如下：
1、菜鸟教程网址：www.runoob.com
创建格式化字符串
我们知道输出格式化数字可以使用 printf()和 format()方法。String 类使用静态方法 format()返回一个 String 对象而不是 PrintStream 对象。
String 类的静态方法 format()能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。如下所示：
System.out.printf("浮点型变量的的值为 " +
                  "%f, 整型变量的值为 " +
                  " %d, 字符串变量的值为 " +
                  "is %s", floatVar, intVar, stringVar);
你也可以这样写
String fs;
fs = String.format("浮点型变量的的值为 " +
                   "%f, 整型变量的值为 " +
                   " %d, 字符串变量的值为 " +
                   " %s", floatVar, intVar, stringVar);
System.out.println(fs);
String 方法
下面是 String 类支持的方法，更多详细，参看 Java String API 文档:
SN(序号)	方法描述
1	char charAt(int index) 返回指定索引处的 char 值。
2	int compareTo(Object o) 把这个字符串和另一个对象比较。
3	int compareTo(String anotherString) 按字典顺序比较两个字符串。
4	int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。
5	String concat(String str) 将指定字符串连接到此字符串的结尾。
6	boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的 StringButter 有相同顺序的字符时候返回真。
7	static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。
8	static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。
9	boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。
10	boolean equals(Object anObject) 将此字符串与指定的对象比较。
11	boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。
12	byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。
13	byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。
14	void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。
15	int hashCode() 返回此字符串的哈希码。
16	int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。
17	int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。
18	int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。
19	int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。
20	String intern() 返回字符串对象的规范化表示形式。
21	int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。
22	int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。
23	int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。
24	int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。
25	int length() 返回此字符串的长度。
26	boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。
27	boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。
28	boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。
29	String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
30	String replaceAll(String regex, String replacement 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。
31	String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
32	String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。
33	String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。
34	boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。
35	boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。
36	CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。
37	String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。
38	String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。
39	char[] toCharArray() 将此字符串转换为一个新的字符数组。
40	String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。
41	String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。
42	String toString() 返回此对象本身（它已经是一个字符串！）。
43	String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。
44	String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。
45	String trim() 返回字符串的副本，忽略前导空白和尾部空白。
46	static String valueOf(primitive data type x) 返回给定 data type 类型 x 参数的字符串表示形式。
** Java StringBuffer
当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。
StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。
由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。
实例
public class Test{

    public static void main(String args[]){
       StringBuffer sBuffer = new StringBuffer(" test");
       sBuffer.append(" String Buffer");
       System.out.println(sBuffer);  
   }
}
以上实例编译运行结果如下：
test String Buffer
StringBuffer 方法
以下是 StringBuffer 类支持的主要方法：
序号	方法描述
1	public StringBuffer append(String s) 将指定的字符串追加到此字符序列。
2	public StringBuffer reverse() 将此字符序列用其反转形式取代。
3	public delete(int start, int end) 移除此序列的子字符串中的字符。
4	public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。
5	replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。
下面的列表里的方法和 String 类的方法类似： 序号	方法描述
1	int capacity() 返回当前容量。
2	char charAt(int index) 返回此序列中指定索引处的 char 值。
3	void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。
4	void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。
5	int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。
6	int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。
7	int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。
8	int lastIndexOf(String str, int fromIndex) 返回最后一次出现的指定子字符串在此字符串中的索引。
9	int length() 返回长度（字符数）。
10	void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。
11	void setLength(int newLength) 设置字符序列的长度。
12	CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。
13	String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。
14	String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。
15	String toString() 返回此序列中数据的字符串表示形式。
** Java 数组
数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。
Java 语言中提供的数组是用来存储固定大小的同类型元素。
你可以声明一个数组变量，如 numbers[100]来代替直接声明 100 个独立变量 number0，number1，....，number99。
本教程将为大家介绍 Java 数组的声明、创建和初始化，并给出其对应的代码。
*** 声明数组变量
首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：
dataType[] arrayRefVar;   // 首选的方法
或
dataType arrayRefVar[];  // 效果相同，但不是首选方法
注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在 Java 中采用是为了让 C/C++ 程序员能够快速理解 java 语言。
实例
下面是这两种语法的代码示例：
double[] myList;         // 首选的方法
或
double myList[];         //  效果相同，但不是首选方法
*** 创建数组
Java 语言使用 new 操作符来创建数组，语法如下：
arrayRefVar = new dataType[arraySize];
上面的语法语句做了两件事：
一、使用 dataType[arraySize]创建了一个数组。
二、把新创建的数组的引用赋值给变量 arrayRefVar。
数组变量的声明，和创建数组可以用一条语句完成，如下所示：
dataType[] arrayRefVar = new dataType[arraySize];
另外，你还可以使用如下的方式创建数组。
dataType[] arrayRefVar = {value0, value1, ..., valuek};
数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。
实例
下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。
#+BEGIN_SRC java
public class TestArray {

   public static void main(String[] args) {
      // 数组大小
      int size = 10;
      // 定义数组
      double[] myList = new double[size];
      myList[0] = 5.6;
      myList[1] = 4.5;
      myList[2] = 3.3;
      myList[3] = 13.2;
      myList[4] = 4.0;
      myList[5] = 34.33;
      myList[6] = 34.0;
      myList[7] = 45.45;
      myList[8] = 99.993;
      myList[9] = 11123;
      // 计算所有元素的总和
      double total = 0;
      for (int i = 0; i < size; i++) {
         total += myList[i];
      }
      System.out.println("总和为： " + total);
   }
}
#+END_SRC
以上实例输出结果为：
总和为：11367.373
下面的图片描绘了数组 myList。这里 myList 数组里有 10 个 double 元素，它的下标从 0 到 9。
java 数组结构说明
*** 处理数组
数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。
示例
该实例完整地展示了如何创建、初始化和操纵数组：
#+BEGIN_SRC java
public class TestArray {

   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};

      // 打印所有数组元素
      for (int i = 0; i < myList.length; i++) {
         System.out.println(myList[i] + " ");
      }
      // 计算所有元素的总和
      double total = 0;
      for (int i = 0; i < myList.length; i++) {
         total += myList[i];
      }
      System.out.println("Total is " + total);
      // 查找最大元素
      double max = myList[0];
      for (int i = 1; i < myList.length; i++) {
         if (myList[i] > max) max = myList[i];
      }
      System.out.println("Max is " + max);
   }
}
#+END_SRC
以上实例编译运行结果如下：
1.9
2.9
3.4
3.5
Total is 11.7
Max is 3.5
*** foreach 循环
JDK 1.5 引进了一种新的循环类型，被称为 foreach 循环或者加强型循环，它能在不使用下标的情况下遍历数组。
示例
该实例用来显示数组 myList 中的所有元素：
#+BEGIN_SRC java
public class TestArray {

   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};

      // 打印所有数组元素
      for (double element: myList) {
         System.out.println(element);
      }
   }
}
#+END_SRC
以上实例编译运行结果如下：
1.9
2.9
3.4
3.5
*** 数组作为函数的参数
数组可以作为参数传递给方法。例如，下面的例子就是一个打印 int 数组中元素的方法。
#+BEGIN_SRC java
public static void printArray(int[] array) {
  for (int i = 0; i < array.length; i++) {
    System.out.print(array[i] + " ");
  }
}
#+END_SRC
下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：
printArray(new int[]{3, 1, 2, 6, 4, 2});
*** 数组作为函数的返回值
#+BEGIN_SRC java
public static int[] reverse(int[] list) {
  int[] result = new int[list.length];

  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {
    result[j] = list[i];
  }
  return result;
}
#+END_SRC
以上实例中 result 数组作为函数的返回值。
*** 多维数组
多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：
String str[][] = new String[3][4];
**** 多维数组的动态初始化（以二维数组为例）
1. 直接为每一维分配空间，格式如下：
type arrayName = new typ[arraylenght1][arraylenght2];
type 可以为基本数据类型和复合数据类型，arraylenght1 和 arraylenght2 必须为正整数，arraylenght1 为行数，arraylenght2 为列数。
例如：
int a[][] = new int[2][3];
解析：
二维数组 a 可以看成一个两行三列的数组。
2. 从最高维开始，分别为每一维分配空间，例如：
#+BEGIN_SRC java
String s[][] = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String("Good");
s[0][1] = new String("Luck");
s[1][0] = new String("to");
s[1][1] = new String("you");
s[1][2] = new String("!");
#+END_SRC
解析：
s[0]=new String[2] 和 s[1]=new String[3] 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 s0=new String("Good") 等操作。
**** 多维数组的引用（以二维数组为例）
对二维数组中的每个元素，引用方式为 arrayName[index1][index2]，例如：
num[1][0];
*** Arrays 类
java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：
给数组赋值：通过 fill 方法。
对数组排序：通过 sort 方法,按升序。
比较数组：通过 equals 方法比较数组中元素值是否相等。
查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。
具体说明请查看下表：
序号	方法和说明
1	public static int binarySearch(Object[] a, Object key)
  用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double 等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。
2	public static boolean equals(long[] a, long[] a2)
  如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int 等）。
3	public static void fill(int[] a, int val)
  将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int 等）。
4	public static void sort(Object[] a)
  对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int 等）。
** Java 日期和时间
java.util 包提供了 Date 类来封装当前的日期和时间。Date 类提供两个构造函数来实例化 Date 对象。
第一个构造函数使用当前日期和时间来初始化对象。
Date( )
第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。
Date(long millisec)
Date 对象创建以后，可以调用下面的方法。
序号	方法和描述
1	boolean after(Date date) 若当调用此方法的 Date 对象在指定日期之后返回 true,否则返回 false。
2	boolean before(Date date) 若当调用此方法的 Date 对象在指定日期之前返回 true,否则返回 false。
3	Object clone( ) 返回此对象的副本。
4	int compareTo(Date date) 比较当调用此方法的 Date 对象和指定日期。两者相等时候返回 0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。
5	int compareTo(Object obj) 若 obj 是 Date 类型则操作等同于 compareTo(Date) 。否则它抛出 ClassCastException。
6	boolean equals(Object date) 当调用此方法的 Date 对象和指定日期相等时候返回 true,否则返回 false。
7	long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。
8	int hashCode( ) 返回此对象的哈希码值。
9	void setTime(long time) 用自 1970 年 1 月 1 日 00:00:00 GMT 以后 time 毫秒数设置时间和日期。
10	String toString( ) 转换 Date 对象为 String 表示形式，并返回该字符串。
- 日期比较
Java 使用以下三种方法来比较两个日期：
使用 getTime( ) 方法获取两个日期（自 1970 年 1 月 1 日经历的毫秒数值），然后比较这两个值。
使用方法 before()，after()和 equals()。例如，一个月的 12 号比 18 号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18))返回 true。
使用 compareTo()方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。
- 使用 SimpleDateFormat 格式化日期
SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：
import java.util.*;
import java.text.*;

public class DateDemo {
   public static void main(String args[]) {

      Date dNow = new Date( );
      SimpleDateFormat ft = 
      new SimpleDateFormat ("E yyyy.MM.dd 'at' hh:mm:ss a zzz");

      System.out.println("Current Date: " + ft.format(dNow));
   }
}
简单的 DateFormat 格式化编码
时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：
字母	描述	示例
G	纪元标记	AD
y	四位年份	2001
M	月份	July or 07
d	一个月的日期	10
h	 A.M./P.M. (1~12)格式小时	12
H	一天中的小时 (0~23)	22
m	分钟数	30
s	秒数	55
S	毫秒数	234
E	星期几	Tuesday
D	一年中的日子	360
F	一个月中第几周的周几	2 (second Wed. in July)
w	一年中第几周	40
W	一个月中第几周	1
a	A.M./P.M. 标记	PM
k	一天中的小时(1~24)	24
K	 A.M./P.M. (0~11)格式小时	10
z	时区	Eastern Standard Time
'	文字定界符	Delimiter
"	单引号	`
- 日期和时间转换字符
字符	描述	例子
c	完整的日期和时间	Mon May 04 09:51:52 CDT 2009
F	ISO 8601 格式日期	2004-02-09
D	U.S. 格式日期 (月/日/年)	02/09/2004
T	24 小时时间	18:05:19
r	12 小时时间	06:05:19 pm
R	24 小时时间，不包含秒	18:05
Y	4 位年份(包含前导 0)	2004
y	年份后 2 位(包含前导 0)	04
C	年份前 2 位(包含前导 0)	20
B	月份全称	February
b	月份简称	Feb
n	2 位月份(包含前导 0)	02
d	2 位日子(包含前导 0)	03
e	2 位日子(不包含前导 0)	9
A	星期全称	Monday
a	星期简称	Mon
j	3 位年份(包含前导 0)	069
H	2 位小时(包含前导 0), 00 到 23	18
k	2 位小时(不包含前导 0),  0 到 23	18
I	2 位小时(包含前导 0), 01 到 12	06
l	2 位小时(不包含前导 0),  1 到 12	6
M	2 位分钟(包含前导 0)	05
S	2 位秒数(包含前导 0)	19
L	3 位毫秒(包含前导 0)	047
N	9 位纳秒(包含前导 0)	047000000
P	大写上下午标志	PM
p	小写上下午标志	pm
z	从 GMT 的 RFC 822 数字偏移	-0800
Z	时区	PST
s	自 1970-01-01 00:00:00 GMT 的秒数	1078884319
Q	自 1970-01-01 00:00:00 GMT 的毫妙	1078884319047
还有其他有用的日期和时间相关的类。对于更多的细节，你可以参考到 Java 标准文档。
- Java 休眠(sleep)
sleep()使当前线程进入停滞状态（阻塞当前线程），让出 CPU 的使用、目的是不让当前线程独自霸占该进程所获的 CPU 资源，以留一定时间给其他线程执行的机会。
你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠 3 秒：
import java.util.*;
Thread.sleep(1000*3);   // 休眠 3 秒
- Calendar 类
我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用 Calendar 类。
Calendar 类的功能要比 Date 类强大很多，而且在实现方式上也比 Date 类要复杂一些。
Calendar 类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用 getInstance 方法创建即可。
创建一个代表系统当前日期的 Calendar 对象
Calendar c = Calendar.getInstance();//默认是当前日期
创建一个指定日期的 Calendar 对象
使用 Calendar 类代表特定的时间，需要首先创建一个 Calendar 的对象，然后再设定该对象中的年月日参数来完成。
//创建一个代表 2009 年 6 月 12 日的 Calendar 对象
Calendar c1 = Calendar.getInstance();
c1.set(2009, 6 - 1, 12);
Calendar 类对象字段类型
Calendar 类中用一下这些常量表示不同的意义，jdk 内的很多类其实都是采用的这种思想
常量	描述
Calendar.YEAR	年份
Calendar.MONTH	月份
Calendar.DATE	日期
Calendar.DAY_OF_MONTH	日期，和上面的字段意义完全相同
Calendar.HOUR	12 小时制的小时
Calendar.HOUR_OF_DAY	24 小时制的小时
Calendar.MINUTE	分钟
Calendar.SECOND	秒
Calendar.DAY_OF_WEEK	星期几 :w
** Java 正则表达式
*** 介绍
正则表达式定义了字符串的模式。
正则表达式可以用来搜索、编辑或处理文本。
正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。
Java 正则表达式和 Perl 的是最为相似的。
java.util.regex 包主要包括以下三个类：
Pattern 类：
  Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。
Matcher 类：
  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与 Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。
PatternSyntaxException：
  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。
*** 正则表达式语法
字符 说明
\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\"匹配"\"，"\("匹配"("。
^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。
$ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。
*
零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。
+
一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。
?
零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。
{n}
n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。
{n,}
n 是非负整数。至少匹配 n 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。
{n,m}
M 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。
?
当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。
.
匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。
(pattern)
匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。
(?:pattern)
匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 'industry|industries' 更经济的表达式。
(?=pattern)
执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95|98|NT|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
(?!pattern)
执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95|98|NT|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
x|y
匹配 x 或 y。例如，'z|food' 匹配"z"或"food"。'(z|f)ood' 匹配"zood"或"food"。
[xyz]
字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。
[^xyz]
反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。
[a-z]
字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。
[^a-z]
反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。
\b
匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。
\B
非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。
\cx
匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。
\d
数字字符匹配。等效于 [0-9]。
\D
非数字字符匹配。等效于 [^0-9]。
\f
换页符匹配。等效于 \x0c 和 \cL。
\n
换行符匹配。等效于 \x0a 和 \cJ。
\r
匹配一个回车符。等效于 \x0d 和 \cM。
\s
匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。
\S
匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。
\t
制表符匹配。与 \x09 和 \cI 等效。
\v
垂直制表符匹配。与 \x0b 和 \cK 等效。
\w
匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。
\W
与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。
\xn
匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。
\num
匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。
\n
标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。
\nm
标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。
\nml
当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。
\un
匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。
*** 例子
import java.util.regex.Matcher;
import java.util.regex.Pattern;
// 按指定模式在字符串查找
      String line = "This order was placed for QT3000! OK?";
      String pattern = "(.*)(\\d+)(.*)";

      // 创建 Pattern 对象
      Pattern r = Pattern.compile(pattern);

      // 现在创建 matcher 对象
      Matcher m = r.matcher(line);
      if (m.find( )) {
         System.out.println("Found value: " + m.group(0) );
         System.out.println("Found value: " + m.group(1) );
         System.out.println("Found value: " + m.group(2) );
      } else {
         System.out.println("NO MATCH");
      }
*** Matcher 类的方法
**** 索引方法
索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：
序号	方法及说明
1	public int start() 
返回以前匹配的初始索引。
2	public int start(int group)
 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引
3	public int end()
返回最后匹配字符之后的偏移量。
4	public int end(int group)
返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。
**** 研究方法
研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：
序号	方法及说明
1	public boolean lookingAt() 
 尝试将从区域开头开始的输入序列与该模式匹配。
2	public boolean find() 
尝试查找与该模式匹配的输入序列的下一个子序列。
3	public boolean find(int start）
重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。
4	public boolean matches() 
尝试将整个区域与模式匹配。
**** 替换方法
替换方法是替换输入字符串里文本的方法：
序号	方法及说明
1	public Matcher appendReplacement(StringBuffer sb, String replacement)
实现非终端添加和替换步骤。
2	public StringBuffer appendTail(StringBuffer sb)
实现终端添加和替换步骤。
3	public String replaceAll(String replacement) 
 替换模式与给定替换字符串相匹配的输入序列的每个子序列。
4	public String replaceFirst(String replacement)
 替换模式与给定替换字符串匹配的输入序列的第一个子序列。
5	public static String quoteReplacement(String s)
返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给 Matcher 类的 appendReplacement 方法一个字面字符串一样工作。
** Java 方法
就是函数
*** 方法的重载
上面使用的 max 方法仅仅适用于 int 型数据。但如果你想得到两个浮点类型数据的最大值呢？
解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：
public static double max(double num1, double num2) {
  if (num1 > num2)
    return num1;
  else
    return num2;
}
如果你调用 max 方法时传递的是 int 型参数，则 int 型参数的 max 方法就会被调用；
如果传递的是 double 型参数，则 double 类型的 max 方法体会被调用，这叫做方法重载；
就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。
Java 编译器根据方法签名判断哪个方法应该被调用。
方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。
重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。
*** 构造方法
当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。
通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。
不管你与否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，它把所有成员初始化为 0。
一旦你定义了自己的构造方法，默认构造方法就会失效。
*** 可变参数
JDK 1.5 开始，Java 支持传递同类型的可变参数给一个方法。
方法的可变参数的声明如下所示：
typeName... parameterName
在方法声明中，在指定参数类型后加一个省略号(...) 。
一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。
实例
public class VarargsDemo {

   public static void main(String args[]) {
      // 调用可变参数的方法
	  printMax(34, 3, 3, 2, 56.5);
      printMax(new double[]{1, 2, 3});
   }

   public static void printMax( double... numbers) {
   if (numbers.length == 0) {
      System.out.println("No argument passed");
      return;
   }

   double result = numbers[0];

   for (int i = 1; i <  numbers.length; i++)
      if (numbers[i] >  result)
      result = numbers[i];
      System.out.println("The max value is " + result);
   }
}
*** finalize() 方法
Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。
例如，你可以使用 finalize()来确保一个对象打开的文件被关闭了。
在 finalize()方法里，你必须指定在对象销毁时候要执行的操作。
finalize()一般格式是：
protected void finalize()
{
   // 在这里终结代码
}

** Java 流(Stream)、文件(File)和 IO
Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。
Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。
一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。
Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。
但本节讲述最基本的和流与 I/O 相关的功能。我们将通过一个个例子来学习这些功能。
*** 读取控制台输入
Java 的控制台输入由 System.in 完成。
为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。
下面是创建 BufferedReader 的基本语法：
BufferedReader br = new BufferedReader(new 
                      InputStreamReader(System.in));
BufferedReader 对象创建后，我们便可以使用 read()方法从控制台读取一个字符，或者用 readLine()方法读取一个字符串。
*** 从控制台读取多字符输入
从 BufferedReader 对象读取一个字符要使用 read()方法，它的语法如下：
int read( ) throws IOException
每次调用 read()方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回-1。该方法抛出 IOException。
下面的程序示范了用 read()方法从控制台不断读取字符直到用户输入"q"。
// 使用 BufferedReader 在控制台读取字符

import java.io.*;

public class BRRead {
   public static void main(String args[]) throws IOException
   {
      char c;
      // 使用 System.in 创建 BufferedReader 
      BufferedReader br = new BufferedReader(new 
                         InputStreamReader(System.in));
      System.out.println("Enter characters, 'q' to quit.");
      // 读取字符
      do {
         c = (char) br.read();
         System.out.println(c);
      } while(c != 'q');
   }
}
*** 从控制台读取字符串
从标准输入读取一个字符串需要使用 BufferedReader 的 readLine()方法。
它的一般格式是：
String readLine( ) throws IOException
*** 控制台输出
在此前已经介绍过，控制台的输出由 print( ) 和 println( )完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。
PrintStream 继承了 OutputStream 类，并且实现了方法 write()。这样，write()也可以用来往控制台写操作。
PrintStream 定义 write()的最简单格式如下所示：
void write(int byteval)
*** 读写文件
如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。
下图是一个描述输入流和输出流的类层次图。
http://www.runoob.com/wp-content/uploads/2013/12/12-130Q122402I57.jpg
*** FileInputStream
该流用于从文件读取数据，它的对象可以用关键字 new 来创建。
有多种构造方法可用来创建对象。
可以使用字符串类型的文件名来创建一个输入流对象来读取文件：
InputStream f = new FileInputStream("C:/java/hello");
也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File()方法来创建一个文件对象：
File f = new File("C:/java/hello");
InputStream f = new FileInputStream(f);
创建了 InputStream 对象，就可以使用下面的方法来读取流或者进行其他的流操作。
序号	方法及描述
1	public void close() throws IOException{}
关闭此文件输入流并释放与此流有关的所有系统资源。抛出 IOException 异常。
2	protected void finalize()throws IOException {}
这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出 IOException 异常。
3	public int read(int r)throws IOException{}
这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。
4	public int read(byte[] r) throws IOException{}
这个方法从输入流读取 r.length 长度的字节。返回读取的字节数。如果是文件结尾则返回-1。
5	public int available() throws IOException{}
返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。
除了 InputStream 外，还有一些其他的输入流，更多的细节参考下面链接：
ByteArrayInputStream
DataInputStream
*** FileOutputStream
该类用来创建一个文件并向文件中写数据。
如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。
有两个构造方法可以用来创建 FileOutputStream 对象。
使用字符串类型的文件名来创建一个输出流对象：
OutputStream f = new FileOutputStream("C:/java/hello") 
也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用 File()方法来创建一个文件对象：
File f = new File("C:/java/hello");
OutputStream f = new FileOutputStream(f);
创建 OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。
序号	方法及描述
1	public void close() throws IOException{}
关闭此文件输入流并释放与此流有关的所有系统资源。抛出 IOException 异常。
2	protected void finalize()throws IOException {}
这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出 IOException 异常。
3	public void write(int w)throws IOException{}
这个方法把指定的字节写到输出流中。
4	public void write(byte[] w)
把指定数组中 w.length 长度的字节写到 OutputStream 中。
除了 OutputStream 外，还有一些其他的输出流，更多的细节参考下面链接：
ByteArrayOutputStream
DataOutputStream
*** Java 中的目录
**** 创建目录：
File 类中有两个方法可以用来创建文件夹：
mkdir( )方法创建一个文件夹，成功则返回 true，失败则返回 false。失败表明 File 对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。
mkdirs()方法创建一个文件夹和它的所有父文件夹。
下面的例子创建 "/tmp/user/java/bin"文件夹：
import java.io.File;

public class CreateDir {
   public static void main(String args[]) {
      String dirname = "/tmp/user/java/bin";
      File d = new File(dirname);
      // 现在创建目录
      d.mkdirs();
  }
}
**** 读取目录
一个目录其实就是一个 File 对象，它包含其他文件和文件夹。
如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory( )方法会返回 true。
可以通过调用该对象上的 list()方法，来提取它包含的文件和文件夹的列表。
下面展示的例子说明如何使用 list()方法来检查一个文件夹中包含的内容：
import java.io.File;

public class DirList {
   public static void main(String args[]) {
      String dirname = "/tmp";
      File f1 = new File(dirname);
      if (f1.isDirectory()) {
         System.out.println( "Directory of " + dirname);
         String s[] = f1.list();
         for (int i=0; i < s.length; i++) {
            File f = new File(dirname + "/" + s[i]);
            if (f.isDirectory()) {
               System.out.println(s[i] + " is a directory");
            } else {
               System.out.println(s[i] + " is a file");
            }
         }
      } else {
         System.out.println(dirname + " is not a directory");
    }
  }
}
** Java Scanner 类
java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。
下面是创建 Scanner 对象的基本语法：
 Scanner s = new Scanner(System.in); 
接下来我们演示一个最简单的的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 haxNextLine 判断是否还有输入的数据：
next()与 nextLine()区别
next():
1、一定要读取到有效字符后才可以结束输入。
2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。
3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
next()不能得到带有空格的字符串。
nextLine()：
1、以 Enter 为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
2、可以获得空白。
如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：
** Java 异常处理
异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。
比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用 System.out.println(11/0)，那么你是因为你用 0 做了除数，会抛出 java.lang.ArithmeticException 的异常。
异常发生的原因有很多，通常包含以下几大类：
用户输入了非法数据。
要打开的文件不存在。
网络通信时连接中断，或者 JVM 内存溢出。
这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-
要理解 Java 异常处理是如何工作的，你需要掌握以下三种类型的异常：
检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。
*** Exception 类的层次
所有的异常类是从 java.lang.Exception 类继承的子类。
Exception 类是 Throwable 类的子类。除了 Exception 类外，Throwable 还有一个子类 Error。
Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在 Java 程序处理的范畴之外。
Error 用来指示运行时环境发生的错误。
例如，JVM 内存溢出。一般地，程序不会从错误中恢复。
异常类有两个主要的子类：IOException 类和 RuntimeException 类。
*** Java 内置异常类
Java 语言定义了一些异常类在 java.lang 标准包中。
标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。
Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。
异常	描述
ArithmeticException	当出现异常的运算条件时，抛出此异常。例如，一个整数"除以零"时，抛出此类的一个实例。
ArrayIndexOutOfBoundsException	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。
ArrayStoreException	试图将错误类型的对象存储到一个对象数组时抛出的异常。
ClassCastException	当试图将对象强制转换为不是实例的子类时，抛出该异常。
IllegalArgumentException	抛出的异常表明向方法传递了一个不合法或不正确的参数。
IllegalMonitorStateException	抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。
IllegalStateException	在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。
IllegalThreadStateException	线程没有处于请求操作所要求的适当状态时抛出的异常。
IndexOutOfBoundsException	指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
NegativeArraySizeException	如果应用程序试图创建大小为负的数组，则抛出该异常。
NullPointerException	当应用程序试图在需要对象的地方使用 null 时，抛出该异常
NumberFormatException	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
SecurityException	由安全管理器抛出的异常，指示存在安全侵犯。
StringIndexOutOfBoundsException	此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。
UnsupportedOperationException	当不支持请求的操作时，抛出该异常。

*** 下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。
异常	描述
ClassNotFoundException	应用程序试图加载类时，找不到相应的类，抛出该异常。
CloneNotSupportedException	当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。
IllegalAccessException	拒绝访问一个类的时候，抛出该异常。
InstantiationException	当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。
InterruptedException	一个线程被另一个线程中断，抛出该异常。
NoSuchFieldException	请求的变量不存在
NoSuchMethodException	请求的方法不存在
*** 异常方法
下面的列表是 Throwable 类的主要方法:
序号	方法及说明
1	public String getMessage()
返回关于发生的异常的详细信息。这个消息在 Throwable 类的构造函数中初始化了。
2	public Throwable getCause()
返回一个 Throwable 对象代表异常原因。
3	public String toString()
使用 getMessage()的结果返回类的串级名字。
4	public void printStackTrace()
打印 toString()结果和栈层次到 System.err，即错误输出流。
5	public StackTraceElement [] getStackTrace()
返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。
6	public Throwable fillInStackTrace()
用当前的调用栈层次填充 Throwable 对象栈层次，添加到栈层次任何先前信息中。
*** 捕获异常
使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。
try/catch 代码块中的代码称为保护代码，使用 try/catch 的语法如下：
try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。
如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。
 try{
    // 程序代码
 }catch(异常类型 1 异常的变量名 1){
    // 程序代码
 }catch(异常类型 2 异常的变量名 2){
    // 程序代码
 }catch(异常类型 2 异常的变量名 2){
    // 程序代码
 }
*** throws/throw 关键字：
如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。
也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。
下面方法的声明抛出一个 RemoteException 异常：
import java.io.*;
public class className
{
   public void deposit(double amount) throws RemoteException
   {
      // Method implementation
      throw new RemoteException();
   }
   //Remainder of class definition
}
*** finally 关键字
finally 关键字用来创建在 try 代码块后面执行的代码块。
无论是否发生异常，finally 代码块中的代码总会被执行。
在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。
finally 代码块出现在 catch 代码块最后，语法如下：
 try{
    // 程序代码
 }catch(异常类型 1 异常的变量名 1){
    // 程序代码
 }catch(异常类型 2 异常的变量名 2){
    // 程序代码
 }finally{
    // 程序代码
 }
**** 注意下面事项：
catch 不能独立于 try 存在。
在 try/catch 后面添加 finally 块并非强制性要求的。
try 代码后不能既没 catch 块也没 finally 块。
try, catch, finally 块之间不能添加任何代码。
*** 声明自定义异常
在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。
所有异常都必须是 Throwable 的子类。
如果希望写一个检查性异常类，则需要继承 Exception 类。
如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。
可以像下面这样定义自己的异常类：
class MyException extends Exception{
}
只继承 Exception 类来创建的异常类是检查性异常类。
下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。
一个异常类和其它任何类一样，包含有变量和方法。
- 实例
// 文件名 InsufficientFundsException.java
import java.io.*;

public class InsufficientFundsException extends Exception
{
   private double amount;
   public InsufficientFundsException(double amount)
   {
      this.amount = amount;
   } 
   public double getAmount()
   {
      return amount;
   }
}
*** 通用异常
在 Java 中定义了两种类型的异常和错误。
JVM(Java 虚拟机)异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。
程序级异常：由程序或者 API 程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。
* Java 面向对象
** Java 继承
继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。
如果类 A 是类 B 的父类，而类 B 是类 C 的父类，我们也称 C 是 A 的子类，类 C 是从类 A 继承而来的。在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类
继承中最常使用的两个关键字是 extends 和 implements。
这两个关键字的使用决定了一个对象和另一个对象是否是 IS-A(是一个)关系。
通过使用这两个关键字，我们能实现一个对象获取另一个对象的属性。
所有 Java 的类均是由 java.lang.Object 类继承而来的，所以 Object 是所有类的祖先类，而除了 Object 外，所有类必须有一个父类。
*** extends
通过过 extends 关键字可以申明一个类是继承另外一个类而来的，一般形式如下：
// A.java
public class A {
    private int i;
    protected int j;
 
    public void func() {
 
    }
}
 
// B.java
public class B extends A {
}
- 作为子类，B 的实例拥有 A 所有的成员变量，但对于 private 的成员变量 B 却没有访问权限，这保障了 A 的封装性。
通过使用关键字 extends，子类可以继承父类所有的方法和属性，但是无法使用 private(私有) 的方法和属性。
*** implements
介绍完 extends 关键字之后，我们再来看下 implements 关键字是怎样使用来表示 IS-A 关系。
Implements 关键字使用在类继承接口的情况下， 这种情况不能使用关键字 extends。
实例
public interface Animal {}

public class Mammal implements Animal{
}

public class Dog extends Mammal{
}
*** instanceOf 关键字
我们通过使用 instanceof 操作符，能够确定 Mammal IS-A Animal
System.out.println(d instanceof Animal);
*** HAS-A
 HAS-A 代表类和它的成员之间的从属关系。这有助于代码的重用和减少代码的错误。
例子
public class Vehicle{}
public class Speed{}
public class Van extends Vehicle{
	private Speed sp;
} 
Van 类和 Speed 类是 HAS-A 关系(Van 有一个 Speed)，这样就不用将 Speed 类的全部代码粘贴到 Van 类中了，并且 Speed 类也可以重复利用于多个应用程序。
在面向对象特性中，用户不必担心类的内部怎样实现。
Van 类将实现的细节对用户隐藏起来，因此，用户只需要知道怎样调用 Van 类来完成某一功能，而不必知道 Van 类是自己来做还是调用其他类来做这些工作。
Java 只支持单继承，也就是说，一个类不能继承多个类。
下面的做法是不合法的：
public class extends Animal, Mammal{} 
Java 只支持单继承（继承基本类和抽象类），但是我们可以用接口来实现（多继承接口来实现）,脚本结构如：
public class Apple extends Fruit implements Fruit1, Fruit2{}
一般我们继承基本类和抽象类用 extends 关键字，实现接口类的继承用 implements 关键字。
** Java 重写(Override)与重载(Overload)
*** 重写(Override)
重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。
也就是说子类能够根据需要实现父类的方法。
在面向对象原则里，重写意味着可以重写任何现有方法。
#+BEGIN_SRC java
class Animal{

   public void move(){
      System.out.println("动物可以移动");
   }
}

class Dog extends Animal{

   public void move(){
      System.out.println("狗可以跑和走");
   }
}

public class TestDog{

   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象

      a.move();// 执行 Animal 类的方法

      b.move();//执行 Dog 类的方法
   }
}
#+END_SRC
以上实例编译运行结果如下：
动物可以移动
狗可以跑和走
在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move 方法。
这是由于在编译阶段，只是检查参数的引用类型。
然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。
因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。
思考以下例子：
*** 方法的重写规则
参数列表必须完全与被重写方法的相同；
返回类型必须完全与被重写方法的返回类型相同；
访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
父类的成员方法只能被它的子类重写。
声明为 final 的方法不能被重写。
声明为 static 的方法不能被重写，但是能够被再次声明。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
构造方法不能被重写。
如果不能继承一个方法，则不能重写这个方法。
*** Super 关键字的使用
当需要在子类中调用父类的被重写方法时，要使用 super 关键字。
#+BEGIN_SRC java
class Animal{

   public void move(){
      System.out.println("动物可以移动");
   }
}

class Dog extends Animal{

   public void move(){
      super.move(); // 应用 super 类的方法
      System.out.println("狗可以跑和走");
   }
}

public class TestDog{

   public static void main(String args[]){

      Animal b = new Dog(); // Dog 对象
      b.move(); //执行 Dog 类的方法

   }
}
#+END_SRC
*** 重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
只能重载构造函数
**** 重载规则
- 被重载的方法必须改变参数列表；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
#+BEGIN_SRC java
public class Overloading {
 
	public int test(){
		System.out.println("test1");
		return 1;
	}
 
	public void test(int a){
		System.out.println("test2");
	}	
 
	//以下两个参数类型顺序不同
	public String test(int a,String s){
		System.out.println("test3");
		return "returntest3";
	}	
 
	public String test(String s,int a){
		System.out.println("test4");
		return "returntest4";
	}	
 
	public static void main(String[] args){
		Overloading o = new Overloading();
		System.out.println(o.test());
		o.test(1);
		System.out.println(o.test(1,"test3"));
		System.out.println(o.test("test4",1));
	}
}
#+END_SRC
*** 重写与重载之间的区别
区别点	重载方法	重写方法
参数列表	必须修改	一定不能修改
返回类型	可以修改	一定不能修改
异常	可以修改	可以减少或删除，一定不能抛出新的或者更广的异常
访问	可以修改	一定不能做更严格的限制（可以降低限制）
** Java 多态
多态是同一个行为具有多个不同表现形式或形态的能力。
多态性是对象多种表现形式的体现。
#+begin_quote
  现实中，比如我们按下 F1 键这个动作：
  如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
  如果当前在 Word 下弹出的就是 Word 帮助；
  在 Windows 下弹出的就是 Windows 帮助和支持。
  同一个事件发生在不同的对象上会产生不同的结果。
#+end_quote
- 多态存在的三个必要条件:
  1. 继承
  2. 重写
  3. 父类引用指向子类对象
#+BEGIN_SRC java
public class Test {
    public static void main(String[] args) {
      show(new Cat());  // 以 Cat 对象调用 show 方法
      show(new Dog());  // 以 Dog 对象调用 show 方法
                
      Animal a = new Cat();  // 向上转型  
      a.eat();               // 调用的是 Cat 的 eat
      Cat c = (Cat)a;        // 向下转型  
      c.work();        // 调用的是 Cat 的 catchMouse
  }  
            
    public static void show(Animal a)  {
      a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}

abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println("吃鱼");  
    }  
    public void work() {  
        System.out.println("抓老鼠");  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println("吃骨头");  
    }  
    public void work() {  
        System.out.println("看家");  
    }  
}  
#+END_SRC
当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。
多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。
*** 虚方法
我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。
我们已经讨论了方法的重写，也就是子类能够重写父类的方法。
当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。
要想调用父类中被重写的方法，则必须使用关键字 super。
** Java 抽象类
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
#+BEGIN_SRC java
/* 文件名 : Employee.java */
public abstract class Employee
{
   private String name;
   private String address;
   private int number;
   public Employee(String name, String address, int number)
   {
      System.out.println("Constructing an Employee");
      this.name = name;
      this.address = address;
      this.number = number;
   }
   public double computePay()
   {
     System.out.println("Inside Employee computePay");
     return 0.0;
   }
   public void mailCheck()
   {
      System.out.println("Mailing a check to " + this.name
       + " " + this.address);
   }
   public String toString()
   {
      return name + " " + address + " " + number;
   }
   public String getName()
   {
      return name;
   }
   public String getAddress()
   {
      return address;
   }
   public void setAddress(String newAddress)
   {
      address = newAddress;
   }
   public int getNumber()
   {
     return number;
   }
}
#+END_SRC
只有继承后才能实例化
*** 抽象方法
如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。
Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。
抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。
#+BEGIN_SRC java
public abstract class Employee
{
   private String name;
   private String address;
   private int number;
   
   public abstract double computePay();
   
   //其余代码
}
#+END_SRC
- 声明抽象方法会造成以下两个结果：
  1. 如果一个类包含抽象方法，那么该类必须是抽象类。
  2. 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。
继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。
** Java 封装
在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。
封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。
要访问该类的代码和数据，必须通过严格的接口控制。
封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。
适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。
** Java 接口
接口（英文：Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
- 接口与类相似点：
  1. 一个接口可以有多个方法。
  2. 接口文件保存在.java 结尾的文件中，文件名使用接口名。
  3. 接口的字节码文件保存在.class 结尾的文件中。
  4. 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 
- 接口与类的区别：
  1. 接口不能用于实例化对象。
  2. 接口没有构造方法。
  3. 接口中所有的方法必须是抽象方法。
  4. 接口不能包含成员变量，除了 static 和 final 变量。
  5. 接口不是被类继承了，而是要被类实现。
  6. 接口支持多重继承。
*** 接口的声明
接口的声明语法格式如下：
接口的声明语法格式如下：
[可见度] interface 接口名称 [extends 其他的类名] {
        // 声明变量
        // 抽象方法
}
Interface 关键字用来声明一个接口。下面是接口声明的一个简单例子。
#+BEGIN_SRC java
/* 文件名 : NameOfInterface.java */
import java.lang.*;
//引入包

public interface NameOfInterface
{
   //任何类型 final, static 字段
   //抽象方法
}
#+END_SRC
接口有以下特性：
接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。
接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键子。
接口中的方法都是公有的。
#+BEGIN_SRC java
/* 文件名 : Animal.java */
interface Animal {

   public void eat();
   public void travel();
}
#+END_SRC
*** 接口的实现
当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。
类使用 implements 关键字实现接口。在类声明中，Implements 关键字放在 class 声明后面。
实现一个接口的语法，可以使用这个公式：
... implements 接口名称[, 其他接口, 其他接口..., ...] ...
#+BEGIN_SRC java
/* 文件名 : MammalInt.java */
public class MammalInt implements Animal{

   public void eat(){
      System.out.println("Mammal eats");
   }

   public void travel(){
      System.out.println("Mammal travels");
   } 

   public int noOfLegs(){
      return 0;
   }

   public static void main(String args[]){
      MammalInt m = new MammalInt();
      m.eat();
      m.travel();
   }
} 
#+END_SRC

重写接口中声明的方法时，需要注意以下规则：
类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
如果实现接口的类是抽象类，那么就没必要实现该接口的方法。
在实现接口的时候，也要注意一些规则：
一个类可以同时实现多个接口。
一个类只能继承一个类，但是能实现多个接口。
一个接口能继承另一个接口，这和类之间的继承比较相似。
*** 接口的继承
一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。
下面的 Sports 接口被 Hockey 和 Football 接口继承：
#+BEGIN_SRC java
// 文件名: Sports.java
public interface Sports
{
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}

// 文件名: Football.java
public interface Football extends Sports
{
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}

// 文件名: Hockey.java
public interface Hockey extends Sports
{
   public void homeGoalScored();
   public void visitingGoalScored();
   public void endOfPeriod(int period);
   public void overtimePeriod(int ot);
}
#+END_SRC
*** 接口的多重继承
在 Java 中，类的多重继承是不合法，但接口允许多重继承，。
在接口的多重继承中 extends 关键字只需要使用一次，在其后跟着继承接口。 如下所示：
#+BEGIN_SRC java
public interface Hockey extends Sports, Event
#+END_SRC
以上的程序片段是合法定义的子接口，与类不同的是，接口允许多重继承，而 Sports 及 Event 可能定义或是继承相同的方法
*** 标记接口
最常用的继承接口是没有包含任何方法的接口。
标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。
标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。
例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：
#+BEGIN_SRC java
package java.util;
public interface EventListener
{}
#+END_SRC
没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：
建立一个公共的父接口：
正如 EventListener 接口，这是由几十个其他接口扩展的 Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了 EventListener 接口，Java 虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。
向一个类添加数据类型：
这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。
** Java 包(package)
为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。
- 包的作用
  1. 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
  2. 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
  3. 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。
Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。
包语句的语法格式为：
package pkg1[．pkg2[．pkg3…]];
例如,一个 Something.java 文件它的内容
package net.java.util
public class Something{
   ...
}
那么它的路径应该是 net/java/util/Something.java 这样保存的。package(包)的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。
一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。
以下是一些 Java 中的包：
java.lang-打包基础的类
java.io-包含输入输出功能的函数
开发者可以自己把一组类和接口等打包，并定义自己的 package。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。
由于 package 创建了新的命名空间（namespace），所以不会跟其他 package 中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。
*** 创建包
创建 package 的时候，你需要为这个 package 取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个 package 的声明放在这个源文件的开头。
包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。
如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。
*** import 关键字
为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用"import"语句可完成此功能。
在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：
import package1[.package2…].(classname|*);
如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。
例子
下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss 类的实例如下。
#+BEGIN_SRC java
package payroll;

public class Boss
{
   public void payEmployee(Employee e)
   {
      e.mailCheck();
   }
}
#+END_SRC
如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类
使用类全名描述，例如：
payroll.Employee
用 import 关键字引入，使用通配符"*"
import payroll.*;
使用 import 关键字引入 Employee 类
import payroll.Employee;
注意：
类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。
*** package 的目录结构
类放在包中会有两种主要的结果：
包名成为类名的一部分，正如我们前面讨论的一样。
包名必须与相应的字节码所在的目录结构相吻合。
下面是管理你自己 java 中文件的一种简单方式：
将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java 作为扩展名。例如：
// 文件名 :  Car.java

package vehicle;

public class Car {
   // 类实现  
}
接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。
....\vehicle\Car.java
现在，正确的类名和路径将会是如下样子：
类名 -> vehicle.Car
路径名 -> vehicle\Car.java (in windows)
通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 apple.com，所有的包名都以 com.apple 开头。包名中的每一个部分对应一个子目录。
例如：这个公司有一个 com.apple.computers 的包，这个包包含一个叫做 Dell.java 的源文件，那么相应的，应该有如下面的一连串子目录：
....\com\apple\computers\Dell.java
编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上.class 作为扩展后缀。 例如：
// 文件名: Dell.java

package com.apple.computers;
public class Dell{
      
}
class Ups{
      
}
现在，我们用-d 选项来编译这个文件，如下：
$javac -d . Dell.java
这样会像下面这样放置编译了的文件：
.\com\apple\computers\Dell.class.\com\apple\computers\Ups.class
你可以像下面这样来导入所有 \com\apple\computers\中定义的类、接口等：
import com.apple.computers.*;
编译之后的.class 文件应该和.java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求.class 文件的路径跟相应的.java 的路径一样。你可以分开来安排源码和类的目录。
<path-one>\sources\com\apple\computers\Dell.java
<path-two>\classes\com\apple\computers\Dell.class
这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和 java 虚拟机（JVM）可以找到你程序中使用的所有类型。
类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造.class 文件的路径。
<path- two>\classes 是 class path，package 名字是 com.apple.computers,而编译器和 JVM 会在 <path-two>\classes\com\apple\compters 中找.class 文件。
一个 class path 可能会包含好几个路径。多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。
设置 CLASSPATH 系统变量
用下面的命令显示当前的 CLASSPATH 变量：
Windows 平台（DOS 命令行下）-> C:\> set CLASSPATH
UNIX 平台（Bourne shell 下）-> % echo $CLASSPATH
删除当前 CLASSPATH 变量内容：
Windows 平台（DOS 命令行下）-> C:\> set CLASSPATH=
UNIX 平台（Bourne shell 下）-> % unset CLASSPATH; export CLASSPATH
设置 CLASSPATH 变量:
Windows 平台（DOS 命令行下）-> set CLASSPATH=C:\users\jack\java\classes
UNIX 平台（Bourne shell 下）-> % CLASSPATH=/home/jack/java/classes; export CLASSPATH
* Java 高级教程
** Java 数据结构
Java 工具包提供了强大的数据结构。在 Java 中的数据结构主要包括以下几种接口和类：
- 数据结构
  1. 枚举（Enumeration）
  2. 位集合（BitSet）
  3. 向量（Vector）
  4. 栈（Stack）
  5. 字典（Dictionary）
  6. 哈希表（Hashtable）
  7. 属性（Properties）
以上这些类是传统遗留的，在 Java2 中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。`
*** 描述
枚举（Enumeration）
枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。
例如，枚举定义了一个叫 nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。
关于枚举接口的更多信息，请参见枚举（Enumeration）。
位集合（BitSet）
位集合类实现了一组可以单独设置和清除的位或标志。
该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一"位"，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。
关于该类的更多信息，请参见位集合（BitSet）。
向量（Vector）
向量（Vector）类和传统数组非常相似，但是 Vector 的大小能根据需要动态的变化。
和数组一样，Vector 对象的元素也能通过索引访问。
使用 Vector 类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。
关于该类的更多信息，请参见向量(Vector)
栈（Stack）
栈（Stack）实现了一个后进先出（LIFO）的数据结构。
你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。
当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。
关于该类的更多信息，请参见栈（Stack）。
字典（Dictionary）
字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。
当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用 Dictionary。
由于 Dictionary 类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。
关于该类的更多信息，请参见字典（Dictionary）。
哈希表（Hashtable）
Hashtable 类提供了一种在用户定义键结构的基础上来组织数据的手段。
例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。
哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。
关于该类的更多信息，请参见哈希表（HashTable）。
属性（Properties）
Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。
Properties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties()方法的返回值。
关于该类的更多信息，请参见属性（Properties）。
*** 枚举
序号	方法描述
1	boolean hasMoreElements( )
   测试此枚举是否包含更多的元素。
2	Object nextElement( )
   如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。
#+BEGIN_SRC java
import java.util.Vector;
import java.util.Enumeration;

public class EnumerationTester {

   public static void main(String args[]) {
      Enumeration days;
      Vector dayNames = new Vector();
      dayNames.add("Sunday");
      dayNames.add("Monday");
      dayNames.add("Tuesday");
      dayNames.add("Wednesday");
      dayNames.add("Thursday");
      dayNames.add("Friday");
      dayNames.add("Saturday");
      days = dayNames.elements();
      while (days.hasMoreElements()){
         System.out.println(days.nextElement()); 
      }
   }
}
#+END_SRC
*** Bitset
一个 Bitset 类创建一种特殊类型的数组来保存位值。BitSet 中数组大小会随需要增加。这和位向量（vector of bits）比较类似。
这是一个传统的类，但它在 Java 2 中被完全重新设计。
BitSet 定义了两个构造方法。
第一个构造方法创建一个默认的对象：
BitSet()
第二个方法允许用户指定初始大小。所有位初始化为 0。
BitSet(int size)
**** API
BitSet 中实现了 Cloneable 接口中定义的方法如下表所列：
序号	方法描述
1	void and(BitSet bitSet)
对此目标位 set 和参数位 set 执行逻辑与操作。
2	void andNot(BitSet bitSet)
清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。
3	int cardinality( )
返回此 BitSet 中设置为 true 的位数。
4	void clear( )
将此 BitSet 中的所有位设置为 false。
5	void clear(int index)
将索引指定处的位设置为 false。
6	void clear(int startIndex, int endIndex)
将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false。
7	Object clone( )
复制此 BitSet，生成一个与之相等的新 BitSet。
8	boolean equals(Object bitSet)
将此对象与指定的对象进行比较。
9	void flip(int index)
将指定索引处的位设置为其当前值的补码。
10	void flip(int startIndex, int endIndex)
将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码。
11	boolean get(int index)
返回指定索引处的位值。
12	BitSet get(int startIndex, int endIndex)
返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成。
13	int hashCode( )
返回此位 set 的哈希码值。
14	boolean intersects(BitSet bitSet)
如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 ture。
15	boolean isEmpty( )
如果此 BitSet 中没有包含任何设置为 true 的位，则返回 ture。
16	int length( )
返回此 BitSet 的"逻辑大小"：BitSet 中最高设置位的索引加 1。
17	int nextClearBit(int startIndex)
返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。
18	int nextSetBit(int startIndex)
返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。
19	void or(BitSet bitSet)
对此位 set 和位 set 参数执行逻辑或操作。
20	void set(int index)
将指定索引处的位设置为 true。
21	void set(int index, boolean v)
 将指定索引处的位设置为指定的值。
22	void set(int startIndex, int endIndex)
将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true。
23	void set(int startIndex, int endIndex, boolean v)
将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值。
24	int size( )
返回此 BitSet 表示位值时实际使用空间的位数。
25	String toString( )
返回此位 set 的字符串表示形式。
26	void xor(BitSet bitSet)
对此位 set 和位 set 参数执行逻辑异或操作。
*** Java Vector 类
Vector 类实现了一个动态数组。和 ArrayList 和相似，但是两者是不同的：
Vector 是同步访问的。
Vector 包含了许多传统的方法，这些方法不属于集合框架。
Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。
Vector 类支持 4 种构造方法。
第一种构造方法创建一个默认的向量，默认大小为 10：
  Vector()
第二种构造方法创建指定大小的向量。
  Vector(int size)
第三种构造方法创建指定大小的向量，并且增量用 incr 指定. 增量表示向量每次增加的元素数目。
  Vector(int size,int incr)
第四中构造方法创建一个包含集合 c 元素的向量：
  Vector(Collection c)
**** API
除了从父类继承的方法外 Vector 还定义了以下方法：
序号	方法描述
1	void add(int index, Object element) 
 在此向量的指定位置插入指定的元素。
2	boolean add(Object o) 
 将指定元素添加到此向量的末尾。
3	boolean addAll(Collection c) 
将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。
4	boolean addAll(int index, Collection c) 
在指定位置将指定 Collection 中的所有元素插入到此向量中。
5	void addElement(Object obj) 
 将指定的组件添加到此向量的末尾，将其大小增加 1。
6	int capacity() 
返回此向量的当前容量。
7	void clear() 
从此向量中移除所有元素。
8	Object clone() 
返回向量的一个副本。
9	boolean contains(Object elem) 
如果此向量包含指定的元素，则返回 true。
10	boolean containsAll(Collection c) 
如果此向量包含指定 Collection 中的所有元素，则返回 true。
11	void copyInto(Object[] anArray) 
 将此向量的组件复制到指定的数组中。
12	Object elementAt(int index) 
返回指定索引处的组件。
13	Enumeration elements() 
返回此向量的组件的枚举。
14	void ensureCapacity(int minCapacity) 
增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。
15	boolean equals(Object o) 
比较指定对象与此向量的相等性。
16	Object firstElement() 
返回此向量的第一个组件（位于索引 0) 处的项）。
17	Object get(int index) 
返回向量中指定位置的元素。
18	int hashCode() 
返回此向量的哈希码值。
19	int indexOf(Object elem) 
 返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。
20	int indexOf(Object elem, int index) 
 返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。
21	void insertElementAt(Object obj, int index) 
将指定对象作为此向量中的组件插入到指定的 index 处。
22	boolean isEmpty() 
测试此向量是否不包含组件。
23	Object lastElement() 
返回此向量的最后一个组件。
24	int lastIndexOf(Object elem) 
 返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。
25	int lastIndexOf(Object elem, int index) 
返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。
26	Object remove(int index) 
 移除此向量中指定位置的元素。
27	boolean remove(Object o) 
移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。
28	boolean removeAll(Collection c) 
从此向量中移除包含在指定 Collection 中的所有元素。
29	void removeAllElements() 
从此向量中移除全部组件，并将其大小设置为零。
30	boolean removeElement(Object obj) 
从此向量中移除变量的第一个（索引最小的）匹配项。
31	void removeElementAt(int index) 
删除指定索引处的组件。
32	protected void removeRange(int fromIndex, int toIndex)
从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。
33	boolean retainAll(Collection c) 
在此向量中仅保留包含在指定 Collection 中的元素。
34	Object set(int index, Object element)
 用指定的元素替换此向量中指定位置处的元素。
35	void setElementAt(Object obj, int index) 
将此向量指定 index 处的组件设置为指定的对象。
36	void setSize(int newSize) 
 设置此向量的大小。
37	int size() 
 返回此向量中的组件数。
38	List subList(int fromIndex, int toIndex) 
返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。
39	Object[] toArray()
 返回一个数组，包含此向量中以恰当顺序存放的所有元素。
40	Object[] toArray(Object[] a) 
返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。
41	String toString() 
返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。
42	void trimToSize() 
  对此向量的容量进行微调，使其等于向量的当前大小。
**** Example
#+BEGIN_SRC java
import java.util.*;

public class VectorDemo {

   public static void main(String args[]) {
      // initial size is 3, increment is 2
      Vector v = new Vector(3, 2);
      System.out.println("Initial size: " + v.size());
      System.out.println("Initial capacity: " +
      v.capacity());
      v.addElement(new Integer(1));
      v.addElement(new Integer(2));
      v.addElement(new Integer(3));
      v.addElement(new Integer(4));
      System.out.println("Capacity after four additions: " +
          v.capacity());

      v.addElement(new Double(5.45));
      System.out.println("Current capacity: " +
      v.capacity());
      v.addElement(new Double(6.08));
      v.addElement(new Integer(7));
      System.out.println("Current capacity: " +
      v.capacity());
      v.addElement(new Float(9.4));
      v.addElement(new Integer(10));
      System.out.println("Current capacity: " +
      v.capacity());
      v.addElement(new Integer(11));
      v.addElement(new Integer(12));
      System.out.println("First element: " +
         (Integer)v.firstElement());
      System.out.println("Last element: " +
         (Integer)v.lastElement());
      if(v.contains(new Integer(3)))
         System.out.println("Vector contains 3.");
      // enumerate the elements in the vector.
      Enumeration vEnum = v.elements();
      System.out.println("\nElements in vector:");
      while(vEnum.hasMoreElements())
         System.out.print(vEnum.nextElement() + " ");
      System.out.println();
   }
}
#+END_SRC
以上实例编译运行结果如下：
Initial size: 0
Initial capacity: 3
Capacity after four additions: 5
Current capacity: 5
Current capacity: 7
Current capacity: 9
First element: 1
Last element: 12
Vector contains 3.

Elements in vector:
1 2 3 4 5.45 6.08 7 9.4 10 11 12

*** Java Stack 类
栈是 Vector 的一个子类，它实现了一个标准的后进先出的栈。
堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由 Vector 定义的所有方法，也定义了自己的一些方法。
Stack()
**** API
除了由 Vector 定义的所有方法，自己也定义了一些方法：
序号	方法描述
1	boolean empty() 
测试堆栈是否为空。
2	Object peek( )
查看堆栈顶部的对象，但不从堆栈中移除它。
3	Object pop( )
移除堆栈顶部的对象，并作为此函数的值返回该对象。
4	Object push(Object element)
把项压入堆栈顶部。
5	int search(Object element)
返回对象在堆栈中的位置，以 1 为基数。
*** Java Dictionary 类
Dictionary 类是一个抽象类，用来存储键/值对，作用和 Map 类相似。
给出键和值，你就可以将值存储在 Dictionary 对象中。一旦该值被存储，就可以通过它的键来获取它。所以和 Map 一样，Dictionary 也可以作为一个键/值对列表。
**** API
Dictionary 定义的抽象方法如下表所示：
序号	方法描述
1	Enumeration elements( )
返回此 dictionary 中值的枚举。
2	Object get(Object key)
返回此 dictionary 中该键所映射到的值。
3	boolean isEmpty( )
测试此 dictionary 是否不存在从键到值的映射。
4	Enumeration keys( )
返回此 dictionary 中的键的枚举。
5	Object put(Object key, Object value)
将指定 key 映射到此 dictionary 中指定 value。
6	Object remove(Object key)
从此 dictionary 中移除 key（及其相应的 value）。
7	int size( )
返回此 dictionary 中条目（不同键）的数量。
Dictionary 类已经过时了。在实际开发中，你可以实现 Map 接口来获取键/值的存储功能。
*** Java Map 接口
Map 接口中键和值一一映射. 可以通过键来获取值。
给定一个键和一个值，你可以将该值存储在一个 Map 对象. 之后，你可以通过键来访问对应的值。
当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常.
当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。
当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。
当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。
**** API
序号	方法描述
1	void clear( )
 从此映射中移除所有映射关系（可选操作）。
2	boolean containsKey(Object k)
如果此映射包含指定键的映射关系，则返回 true。
3	boolean containsValue(Object v)
如果此映射将一个或多个键映射到指定值，则返回 true。
4	Set entrySet( )
返回此映射中包含的映射关系的 Set 视图。
5	boolean equals(Object obj)
比较指定的对象与此映射是否相等。
6	Object get(Object k)
返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。
7	int hashCode( )
返回此映射的哈希码值。
8	boolean isEmpty( )
如果此映射未包含键-值映射关系，则返回 true。
9	Set keySet( )
返回此映射中包含的键的 Set 视图。
10	Object put(Object k, Object v)
将指定的值与此映射中的指定键关联（可选操作）。
11	void putAll(Map m)
从指定映射中将所有映射关系复制到此映射中（可选操作）。
12	Object remove(Object k)
如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。
13	int size( )
返回此映射中的键-值映射关系数。
14	Collection values( )
返回此映射中包含的值的 Collection 视图。
**** Example
#+BEGIN_SRC java
import java.util.*;

public class CollectionsDemo {

   public static void main(String[] args) {
      Map m1 = new HashMap(); 
      m1.put("Zara", "8");
      m1.put("Mahnaz", "31");
      m1.put("Ayan", "12");
      m1.put("Daisy", "14");
      System.out.println();
      System.out.println(" Map Elements");
      System.out.print("\t" + m1);
   }
}
#+END_SRC
*** Java Hashtable 接口
Hashtable 是原始的 java.util 的一部分， 是一个 Dictionary 具体的实现 。
然而，Java 2 重构的 Hashtable 实现了 Map 接口，因此，Hashtable 现在集成到了集合框架中。它和 HashMap 类很相似，但是它支持同步。
像 HashMap 一样，Hashtable 在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。
然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。
Hashtable 定义了四个构造方法。第一个是默认构造方法：
Hashtable()
第二个构造函数创建指定大小的哈希表：
Hashtable(int size)
第三个构造方法创建了一个指定大小的哈希表，并且通过 fillRatio 指定填充比例。
填充比例必须介于 0.0 和 1.0 之间，它决定了哈希表在重新调整大小之前的充满程度：
Hashtable(int size,float fillRatio)
第四个构造方法创建了一个以 M 中元素为初始化元素的哈希表。
哈希表的容量被设置为 M 的两倍。
Hashtable(Map m)
**** API
Hashtable 中除了从 Map 接口中定义的方法外，还定义了以下方法：
序号	方法描述
1	void clear( )
 将此哈希表清空，使其不包含任何键。
2	Object clone( )
创建此哈希表的浅表副本。
3	boolean contains(Object value)
 测试此映射表中是否存在与指定值关联的键。
4	boolean containsKey(Object key)
测试指定对象是否为此哈希表中的键。
5	boolean containsValue(Object value)
如果此 Hashtable 将一个或多个键映射到此值，则返回 true。
6	Enumeration elements( )
返回此哈希表中的值的枚举。
7	Object get(Object key)
 返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。
8	boolean isEmpty( )
测试此哈希表是否没有键映射到值。
9	Enumeration keys( )
 返回此哈希表中的键的枚举。
10	Object put(Object key, Object value)
将指定 key 映射到此哈希表中的指定 value。
11	void rehash( )
增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。
12	Object remove(Object key)
从哈希表中移除该键及其相应的值。
13	int size( )
 返回此哈希表中的键的数量。
14	String toString( )
返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 ", " （逗号加空格）分隔开的、括在括号中的一组条目。
**** Example
#+BEGIN_SRC java
import java.util.*;

public class HashTableDemo {

   public static void main(String args[]) {
      // Create a hash map
      Hashtable balance = new Hashtable();
      Enumeration names;
      String str;
      double bal;

      balance.put("Zara", new Double(3434.34));
      balance.put("Mahnaz", new Double(123.22));
      balance.put("Ayan", new Double(1378.00));
      balance.put("Daisy", new Double(99.22));
      balance.put("Qadir", new Double(-19.08));

      // Show all balances in hash table.
      names = balance.keys();
      while(names.hasMoreElements()) {
         str = (String) names.nextElement();
         System.out.println(str + ": " +
         balance.get(str));
      }
      System.out.println();
      // Deposit 1,000 into Zara's account
      bal = ((Double)balance.get("Zara")).doubleValue();
      balance.put("Zara", new Double(bal+1000));
      System.out.println("Zara's new balance: " +
      balance.get("Zara"));
   }
}
#+END_SRC
*** Java Properties 接口
Properties 继承于 Hashtable.表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。
Properties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties()方法的返回值。
Properties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表。
Properties defaults;
Properties 类定义了两个构造方法. 第一个构造方法没有默认值。
Properties()
第二个构造方法使用 propDefault 作为默认值。两种情况下，属性列表都为空：
Properties(Properties propDefault)
**** API
除了从 Hashtable 中所定义的方法，Properties 定义了以下方法：
序号	方法描述
1	String getProperty(String key)
 用指定的键在此属性列表中搜索属性。
2	String getProperty(String key, String defaultProperty)
用指定的键在属性列表中搜索属性。
3	void list(PrintStream streamOut)
 将属性列表输出到指定的输出流。
4	void list(PrintWriter streamOut)
将属性列表输出到指定的输出流。
5	void load(InputStream streamIn) throws IOException
 从输入流中读取属性列表（键和元素对）。
6	Enumeration propertyNames( )
按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。
7	Object setProperty(String key, String value)
 调用 Hashtable 的方法 put。
8	void store(OutputStream streamOut, String description)
 以适合使用  load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。
**** Example
#+BEGIN_SRC java
import java.util.*;

public class PropDemo {

   public static void main(String args[]) {
      Properties capitals = new Properties();
      Set states;
      String str;
      
      capitals.put("Illinois", "Springfield");
      capitals.put("Missouri", "Jefferson City");
      capitals.put("Washington", "Olympia");
      capitals.put("California", "Sacramento");
      capitals.put("Indiana", "Indianapolis");

      // Show all states and capitals in hashtable.
      states = capitals.keySet(); // get set-view of keys
      Iterator itr = states.iterator();
      while(itr.hasNext()) {
         str = (String) itr.next();
         System.out.println("The capital of " +
            str + " is " + capitals.getProperty(str) + ".");
      }
      System.out.println();

      // look for state not in list -- specify default
      str = capitals.getProperty("Florida", "Not Found");
      System.out.println("The capital of Florida is "
          + str + ".");
   }
}
#+END_SRC
** Java 泛型
Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
假定我们有这样一个需求：写一个排序方法，能够对整形数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？
答案是可以使用 Java 泛型。
使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。
*** 泛型方法
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
- 下面是定义泛型方法的规则：
  - 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。
  - 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
  - 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
  - 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int,double,char 的等）。
**** Example
#+BEGIN_SRC java
public class GenericMethodTest
{
   // 泛型方法 printArray                         
   public static < E > void printArray( E[] inputArray )
   {
      // 输出数组元素            
         for ( E element : inputArray ){        
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }

    public static void main( String args[] )
    {
        // 创建不同类型数组：Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

        System.out.println( "整型数组元素为:" );
        printArray( intArray  ); // 传递一个整型数组

        System.out.println( "\n 双精度型数组元素为:" );
        printArray( doubleArray ); // 传递一个双精度型数组

        System.out.println( "\n 字符型数组元素为:" );
        printArray( charArray ); // 传递一个字符型数组
    } 
}
#+END_SRC
有界的类型参数:
可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受 Number 或者 Number 子类的实例。这就是有界类型参数的目的。
要声明一个有界的类型参数，首先列出类型参数的名称，后跟 extends 关键字，最后紧跟它的上界。
**** Example
#+BEGIN_SRC java
public class MaximumTest
{
   // 比较三个值并返回最大值
   public static <T extends Comparable<T>> T maximum(T x, T y, T z)
   {                     
      T max = x; // 假设 x 是初始最大值
      if ( y.compareTo( max ) > 0 ){
         max = y; //y 更大
      }
      if ( z.compareTo( max ) > 0 ){
         max = z; // 现在 z 更大           
      }
      return max; // 返回最大对象
   }
   public static void main( String args[] )
   {
      System.out.printf( "%d, %d 和 %d 中最大的数为 %d\n\n",
                   3, 4, 5, maximum( 3, 4, 5 ) );
 
      System.out.printf( "%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n",
                   6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );
 
      System.out.printf( "%s, %s 和 %s 中最大的数为 %s\n","pear",
         "apple", "orange", maximum( "pear", "apple", "orange" ) );
   }
}
#+END_SRC
*** 泛型类
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。
和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。
**** Example
#+BEGIN_SRC java
public class Box<T> {
   
  private T t;

  public void add(T t) {
    this.t = t;
  }

  public T get() {
    return t;
  }

  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    Box<String> stringBox = new Box<String>();

    integerBox.add(new Integer(10));
    stringBox.add(new String("菜鸟教程"));

    System.out.printf("整型值为 :%d\n\n", integerBox.get());
    System.out.printf("字符串为 :%s\n", stringBox.get());
  }
}
#+END_SRC
** Java 序列化
Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。
将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。
整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。
类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含序列化和反序列化对象的方法。
ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：
public final void writeObject(Object x) throws IOException
上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法：
public final Object readObject() throws IOException, ClassNotFoundException
该方法从流中取出下一个对象，并将对象反序列化。它的返回值为 Object，因此，你需要将它转换成合适的数据类型。
为了演示序列化在 Java 中是怎样工作的，我将使用之前教程中提到的 Employee 类，假设我们定义了如下的 Employee 类，该类实现了 Serializable 接口。
#+BEGIN_SRC java
public class Employee implements java.io.Serializable
{
   public String name;
   public String address;
   public transient int SSN;
   public int number;
   public void mailCheck()
   {
      System.out.println("Mailing a check to " + name
                           + " " + address);
   }
}
#+END_SRC
请注意，一个类的对象要想序列化成功，必须满足两个条件：
该类必须实现 java.io.Serializable 对象。
该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。
如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable 接口。
*** 序列化对象
ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。
该程序执行后，就创建了一个名为 employee.ser 文件。该程序没有任何输出，但是你可以通过代码研读来理解程序的作用。
注意： 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个.ser 扩展名。
#+BEGIN_SRC java
import java.io.*;

public class SerializeDemo
{
   public static void main(String [] args)
   {
      Employee e = new Employee();
      e.name = "Reyan Ali";
      e.address = "Phokka Kuan, Ambehta Peer";
      e.SSN = 11122333;
      e.number = 101;
      try
      {
         FileOutputStream fileOut =
         new FileOutputStream("/tmp/employee.ser");
         ObjectOutputStream out = new ObjectOutputStream(fileOut);
         out.writeObject(e);
         out.close();
         fileOut.close();
         System.out.printf("Serialized data is saved in /tmp/employee.ser");
      }catch(IOException i)
      {
          i.printStackTrace();
      }
   }
}
#+END_SRC
*** 反序列化对象
下面的 DeserializeDemo 程序实例了反序列化，/tmp/employee.ser 存储了 Employee 对象。
#+BEGIN_SRC java
import java.io.*;
public class DeserializeDemo
{
   public static void main(String [] args)
   {
      Employee e = null;
      try
      {
         FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
         ObjectInputStream in = new ObjectInputStream(fileIn);
         e = (Employee) in.readObject();
         in.close();
         fileIn.close();
      }catch(IOException i)
      {
         i.printStackTrace();
         return;
      }catch(ClassNotFoundException c)
      {
         System.out.println("Employee class not found");
         c.printStackTrace();
         return;
      }
      System.out.println("Deserialized Employee...");
      System.out.println("Name: " + e.name);
      System.out.println("Address: " + e.address);
      System.out.println("SSN: " + e.SSN);
      System.out.println("Number: " + e.number);
    }
}
#+END_SRC
以上程序编译运行结果如下所示：
Deserialized Employee...
Name: Reyan Ali
Address:Phokka Kuan, Ambehta Peer
SSN: 0
Number:101
这里要注意以下要点：
readObject() 方法中的 try/catch 代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果 JVM 在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。
注意，readObject()方法的返回值被转化成 Employee 引用。
当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。
** Java 网络编程
网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。
java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。
java.net 包中提供了两种常见的网络协议的支持：
TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。
UDP:UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。
本教程主要讲解以下两个主题。
Socket 编程: 这是使用最广泛的网络概念，它已被解释地非常详细
URL 处理: 这部分会在另外的篇幅里讲，点击这里更详细地了解在 Java 语言中的 URL 处理。
Socket 编程
套接字使用 TCP 提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。
当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行进行通信。
java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。
以下步骤在两台计算机之间使用套接字建立 TCP 连接时会出现：
服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。
服务器调用 ServerSocket 类 的 accept（）方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。
服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。
Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。
在服务器端，accept()方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。
连接建立后，通过使用 I/O 流在进行通信。每一个 socket 都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。
TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 sockets。
ServerSocket 类的方法
服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。
ServerSocket 类有四个构造方法：
序号	方法描述
1	public ServerSocket(int port) throws IOException
创建绑定到特定端口的服务器套接字。
2	public ServerSocket(int port, int backlog) throws IOException
利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。
3	public ServerSocket(int port, int backlog, InetAddress address) throws IOException
使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。
4	public ServerSocket() throws IOException
创建非绑定服务器套接字。
创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。
这里有一些 ServerSocket 类的常用方法：
序号	方法描述
1	public int getLocalPort()
  返回此套接字在其上侦听的端口。
2	public Socket accept() throws IOException
侦听并接受到此套接字的连接。
3	public void setSoTimeout(int timeout)
 通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。
4	public void bind(SocketAddress host, int backlog)
将 ServerSocket 绑定到特定地址（IP 地址和端口号）。
Socket 类的方法
java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept()方法的返回值。
Socket 类有五个构造方法.
序号	方法描述
1	public Socket(String host, int port) throws UnknownHostException, IOException.
创建一个流套接字并将其连接到指定主机上的指定端口号。
2	public Socket(InetAddress host, int port) throws IOException
创建一个流套接字并将其连接到指定 IP 地址的指定端口号。
3	public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.
创建一个套接字并将其连接到指定远程主机上的指定远程端口。
4	public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.
创建一个套接字并将其连接到指定远程地址上的指定远程端口。
5	public Socket()
通过系统默认类型的 SocketImpl 创建未连接套接字
当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。
下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。
序号	方法描述
1	public void connect(SocketAddress host, int timeout) throws IOException
将此套接字连接到服务器，并指定一个超时值。
2	public InetAddress getInetAddress()
 返回套接字连接的地址。
3	public int getPort()
返回此套接字连接到的远程端口。
4	public int getLocalPort()
返回此套接字绑定到的本地端口。
5	public SocketAddress getRemoteSocketAddress()
返回此套接字连接的端点的地址，如果未连接则返回 null。
6	public InputStream getInputStream() throws IOException
返回此套接字的输入流。
7	public OutputStream getOutputStream() throws IOException
返回此套接字的输出流。
8	public void close() throws IOException
关闭此套接字。
InetAddress 类的方法
这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：
序号	方法描述
1	static InetAddress getByAddress(byte[] addr)
在给定原始 IP 地址的情况下，返回 InetAddress 对象。
2	static InetAddress getByAddress(String host, byte[] addr)
根据提供的主机名和 IP 地址创建 InetAddress。
3	static InetAddress getByName(String host)
在给定主机名的情况下确定主机的 IP 地址。
4	String getHostAddress() 
返回 IP 地址字符串（以文本表现形式）。
5	String getHostName() 
 获取此 IP 地址的主机名。
6	static InetAddress getLocalHost()
返回本地主机。
7	String toString()
将此 IP 地址转换为 String。
Socket 客户端实例
如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。
// 文件名 GreetingClient.java
#+BEGIN_SRC java
import java.net.*;
import java.io.*;
 
public class GreetingClient
{
   public static void main(String [] args)
   {
      String serverName = args[0];
      int port = Integer.parseInt(args[1]);
      try
      {
         System.out.println("Connecting to " + serverName
                             + " on port " + port);
         Socket client = new Socket(serverName, port);
         System.out.println("Just connected to "
                      + client.getRemoteSocketAddress());
         OutputStream outToServer = client.getOutputStream();
         DataOutputStream out =
                       new DataOutputStream(outToServer);
 
         out.writeUTF("Hello from "
                      + client.getLocalSocketAddress());
         InputStream inFromServer = client.getInputStream();
         DataInputStream in =
                        new DataInputStream(inFromServer);
         System.out.println("Server says " + in.readUTF());
         client.close();
      }catch(IOException e)
      {
         e.printStackTrace();
      }
   }
}
#+END_SRC
Socket 服务端实例
如下的 GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。
#+BEGIN_SRC java
// 文件名 GreetingServer.java

import java.net.*;
import java.io.*;

public class GreetingServer extends Thread
{
   private ServerSocket serverSocket;
   
   public GreetingServer(int port) throws IOException
   {
      serverSocket = new ServerSocket(port);
      serverSocket.setSoTimeout(10000);
   }

   public void run()
   {
      while(true)
      {
         try
         {
            System.out.println("Waiting for client on port " +
            serverSocket.getLocalPort() + "...");
            Socket server = serverSocket.accept();
            System.out.println("Just connected to "
                  + server.getRemoteSocketAddress());
            DataInputStream in =
                  new DataInputStream(server.getInputStream());
            System.out.println(in.readUTF());
            DataOutputStream out =
                 new DataOutputStream(server.getOutputStream());
            out.writeUTF("Thank you for connecting to "
              + server.getLocalSocketAddress() + "\nGoodbye!");
            server.close();
         }catch(SocketTimeoutException s)
         {
            System.out.println("Socket timed out!");
            break;
         }catch(IOException e)
         {
            e.printStackTrace();
            break;
         }
      }
   }
   public static void main(String [] args)
   {
      int port = Integer.parseInt(args[0]);
      try
      {
         Thread t = new GreetingServer(port);
         t.start();
      }catch(IOException e)
      {
         e.printStackTrace();
      }
   }
}
#+END_SRC
编译以上 java 代码，并执行以下命令来启动服务，使用端口号为 6066：
$ java GreetingServer 6066
Waiting for client on port 6066... 像下面一样开启客户端：
$ java GreetingClient localhost 6066
Connecting to localhost on port 6066
Just connected to localhost/127.0.0.1:6066
Server says Thank you for connecting to /127.0.0.1:6066
Goodbye!
** Java 多线程编程
Java 给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。
多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。
这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。
多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。
*** 一个线程的生命周
线程经过其生命周期的各个阶段。下图显示了一个线程完整的生命周期。
java_thread
新建状态:
使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
就绪状态:
当线程对象调用了 start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。
运行状态:
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
阻塞状态:
如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
等待阻塞：运行状态中的线程执行 wait()方法，使线程进入到等待阻塞状态。
同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
其他阻塞：通过调用线程的 sleep()或 join()发出了 I/O 请求时，线程就会进入到阻塞状态。当 sleep()状态超时，join()等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
死亡状态:
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。
*** 线程的优先级
每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。
Java 线程的优先级是一个整数，其取值范围是 1（Thread.MIN_PRIORITY） - 10（Thread.MAX_PRIORITY）。
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。
具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。
*** 创建一个线程
Java 提供了三种创建线程的方法：
通过实现 Runable 接口；
通过继承 Thread 类本身；
通过 Callable 和 Future 创建线程。
*** 通过实现 Runnable 接口来创建线程
创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。
为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：
public void run()
你可以重写该方法，重要的是理解的 run()可以调用其他方法，使用其他类，并声明变量，就像主线程一样。
在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。
Thread 定义了几个构造方法，下面的这个是我们经常使用的：
Thread(Runnable threadOb,String threadName);
这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。
新线程创建之后，你调用它的 start()方法它才会运行。
void start();
下面是一个创建线程并开始让它执行的实例：
实例
#+BEGIN_SRC java
class RunnableDemo implements Runnable {
  private Thread t;
  private String threadName;
  RunnableDemo( String name) {
    threadName = name;
    System.out.println("Creating " + threadName );
  }
  public void run() {
    System.out.println("Running " + threadName );
  try {
    for(int i = 4; i > 0; i--) {
      System.out.println("Thread: " + threadName + ", " + i);
      // 让线程睡眠一会
      Thread.sleep(50);
    }
  }catch (InterruptedException e) {
    System.out.println("Thread " + threadName + " interrupted.");
  }
    System.out.println("Thread " + threadName + " exiting.");
  }
  public void start () {
    System.out.println("Starting " + threadName );
    if (t == null) {
      t = new Thread (this, threadName);
      t.start ();
    }
  }
}
public class TestThread {
public static void main(String args[]) {
  RunnableDemo R1 = new RunnableDemo( "Thread-1");
  R1.start();
  RunnableDemo R2 = new RunnableDemo( "Thread-2");
  R2.start();
}
}
#+END_SRC
编译以上程序运行结果如下：
Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
*** 通过继承 Thread 来创建线程
创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。
继承类必须重写 run()方法，该方法是新线程的入口点。它也必须调用 start()方法才能执行。
该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。
实例
#+BEGIN_SRC java
class ThreadDemo extends Thread {
    private Thread t;
    private String threadName;
    ThreadDemo( String name) {
        threadName = name;
        System.out.println("Creating " + threadName );
    }
    public void run() {
        System.out.println("Running " + threadName );
        try {
            for(int i = 4; i > 0; i--) {
                System.out.println("Thread: " + threadName + ", " + i);
                // 让线程睡醒一会
                Thread.sleep(50);
            }
        }catch (InterruptedException e) {
            System.out.println("Thread " + threadName + " interrupted.");
        }
        System.out.println("Thread " + threadName + " exiting.");
    }
    public void start () {
        System.out.println("Starting " + threadName );
        if (t == null) {
            t = new Thread (this, threadName);
            t.start ();
        }
    }
}
public class TestThread {
    public static void main(String args[]) {
        ThreadDemo T1 = new ThreadDemo( "Thread-1");
        T1.start();
        ThreadDemo T2 = new ThreadDemo( "Thread-2");
        T2.start();
    }
}
#+END_SRC

编译以上程序运行结果如下：
Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
*** Thread 方法
下表列出了 Thread 类的一些重要方法：
序号	方法描述
1	public void start()
使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
2	public void run()
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。
3	public final void setName(String name)
改变线程名称，使之与参数 name 相同。
4	public final void setPriority(int priority)
 更改线程的优先级。
5	public final void setDaemon(boolean on)
将该线程标记为守护线程或用户线程。
6	public final void join(long millisec)
等待该线程终止的时间最长为 millis 毫秒。
7	public void interrupt()
中断线程。
8	public final boolean isAlive()
测试线程是否处于活动状态。
测试线程是否处于活动状态。 上述方法是被 Thread 对象调用的。下面的方法是 Thread 类的静态方法。
序号	方法描述
1	public static void yield()
暂停当前正在执行的线程对象，并执行其他线程。
2	public static void sleep(long millisec)
在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
3	public static boolean holdsLock(Object x)
当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。
4	public static Thread currentThread()
返回对当前正在执行的线程对象的引用。
5	public static void dumpStack()
将当前线程的堆栈跟踪打印至标准错误流。
实例
如下的 ThreadClassDemo 程序演示了 Thread 类的一些方法：
DisplayMessage.java 文件代码：
#+BEGIN_SRC java
// 文件名 : DisplayMessage.java
// 通过实现 Runnable 接口创建线程
public class DisplayMessage implements Runnable {
    private String message;
    public DisplayMessage(String message) {
        this.message = message;
    }
    public void run() {
        while(true) {
            System.out.println(message);
        }
    }
}
#+END_SRC
GuessANumber.java 文件代码：
#+BEGIN_SRC java
// 文件名 : GuessANumber.java
// 通过继承 Thread 类创建线程
public class GuessANumber extends Thread {
    private int number;
    public GuessANumber(int number) {
        this.number = number;
    }
    public void run() {
        int counter = 0;
        int guess = 0;
        do {
            guess = (int) (Math.random() * 100 + 1);
            System.out.println(this.getName() + " guesses " + guess);
            counter++;
        } while(guess != number);
        System.out.println("** Correct!" + this.getName() + "in" + counter + "guesses.**");
    }
}
#+END_SRC
ThreadClassDemo.java 文件代码：
#+BEGIN_SRC java
// 文件名 : ThreadClassDemo.java
public class ThreadClassDemo {
    public static void main(String [] args) {
        Runnable hello = new DisplayMessage("Hello");
        Thread thread1 = new Thread(hello);
        thread1.setDaemon(true);
        thread1.setName("hello");
        System.out.println("Starting hello thread...");
        thread1.start();
        Runnable bye = new DisplayMessage("Goodbye");
        Thread thread2 = new Thread(bye);
        thread2.setPriority(Thread.MIN_PRIORITY);
        thread2.setDaemon(true);
        System.out.println("Starting goodbye thread...");
        thread2.start();
        System.out.println("Starting thread3...");
        Thread thread3 = new GuessANumber(27);
        thread3.start();
        try {
            thread3.join();
        }catch(InterruptedException e) {
            System.out.println("Thread interrupted.");
        }
        System.out.println("Starting thread4...");
        Thread thread4 = new GuessANumber(75);
        thread4.start();
        System.out.println("main() is ending...");
    }
}
#+END_SRC
运行结果如下，每一次运行的结果都不一样。
Starting hello thread...
Starting goodbye thread...
Hello
Hello
Hello
Hello
Hello
Hello
Goodbye
Goodbye
Goodbye
Goodbye
Goodbye
.......
*** 通过 Callable 和 Future 创建线程
1. 创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线程执行体，并且有返回值。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call()方法的返回值。。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。。
4. 调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值。
实例
#+BEGIN_SRC java
public class CallableThreadTest implements Callable<Integer> {
    public static void main(String[] args)
    {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for(int i = 0;i < 100;i++)
        {
            System.out.println(Thread.currentThread().getName()+" 的循环变量 i 的值"+i);
            if(i==20)
            {
                new Thread(ft,"有返回值的线程").start();
            }
        }
        try
        {
            System.out.println("子线程的返回值："+ft.get());
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        } catch (ExecutionException e)
        {
            e.printStackTrace();
        }
    }
    @Override
    public Integer call() throws Exception
    {
        int i = 0;
        for(;i<100;i++)
        {
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
        return i;
    }
}
#+END_SRC
*** 创建线程的三种方式的对比
1. 采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。
*** 线程的几个主要概念
在多线程编程时，你需要了解以下几个概念：
线程同步
线程间通信
线程死锁
线程控制：挂起、停止和恢复
*** 多线程的使用
有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。
通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。
请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！
** Java 8
Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。Oracle 公司于 2014 年 3 月 18 日发布 Java 8，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的 Stream API 等。
新特性
Java8 新增了非常多的特性，我们主要讨论以下几个：
Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。
方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。
Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到 Java 中。
Date Time API − 加强对日期与时间的处理。
Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许我们在 JVM 上运行特定的 javascript 应用。
更多的新特性可以参阅官网：What's New in JDK 8
在关于 Java 8 文章的实例，我们均使用 jdk 1.8 环境，你可以使用以下命令查看当前 jdk 的版本：
$ java -version
java version "1.8.0_31"
Java(TM) SE Runtime Environment (build 1.8.0_31-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.31-b07, mixed mode)
编程风格
Java 8 希望有自己的编程风格，并与 Java 7 区别开，以下实例展示了 Java 7 和 Java 8 的编程格式：
#+BEGIN_SRC java
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;

public class Java8Tester {
   public static void main(String args[]){
   
      List<String> names1 = new ArrayList<String>();
      names1.add("Google ");
      names1.add("Runoob ");
      names1.add("Taobao ");
      names1.add("Baidu ");
      names1.add("Sina ");
		
      List<String> names2 = new ArrayList<String>();
      names2.add("Google ");
      names2.add("Runoob ");
      names2.add("Taobao ");
      names2.add("Baidu ");
      names2.add("Sina ");
		
      Java8Tester tester = new Java8Tester();
      System.out.println("使用 Java 7 语法: ");
		
      tester.sortUsingJava7(names1);
      System.out.println(names1);
      System.out.println("使用 Java 8 语法: ");
		
      tester.sortUsingJava8(names2);
      System.out.println(names2);
   }
   
   // 使用 java 7 排序
   private void sortUsingJava7(List<String> names){   
      Collections.sort(names, new Comparator<String>() {
         @Override
         public int compare(String s1, String s2) {
            return s1.compareTo(s2);
         }
      });
   }
   
   // 使用 java 8 排序
   private void sortUsingJava8(List<String> names){
      Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
   }
}
#+END_SRC
执行以上脚本，输出结果为：
$ javac Java8Tester.java
$ java Java8Tester
使用 Java 7 语法: 
[Baidu , Google , Runoob , Sina , Taobao ]
使用 Java 8 语法: 
[Baidu , Google , Runoob , Sina , Taobao ]
接下来我们将详细为大家简介 Java 8 的新特性：
- 序号	特性
  1.	Lambda 表达式
  2.	方法引用
  3.	函数式接口
  4.	默认方法
  5.	Stream
  6.	Optional 类
  7.	Nashorn, JavaScript 引擎
  8.	新的日期时间 API
  9.	Base64
*** Java 8 Lambda 表达式
Java 8 新特性 Java 8 新特性
Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。
Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。
使用 Lambda 表达式可以使代码变的更加简洁紧凑。
语法
lambda 表达式的语法格式如下：
  (parameters) -> expression
或
  (parameters) ->{ statements; }
以下是 lambda 表达式的重要特征:
可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
可选的大括号：如果主体包含了一个语句，就不需要使用大括号。
可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。
Lambda 表达式实例
在 Java8Tester.java 文件输入以下代码：
#+BEGIN_SRC java
public class Java8Tester {
   public static void main(String args[]){
      Java8Tester tester = new Java8Tester();
		
      // 类型声明
      MathOperation addition = (int a, int b) -> a + b;
		
      // 不用类型声明
      MathOperation subtraction = (a, b) -> a - b;
		
      // 大括号中的返回语句
      MathOperation multiplication = (int a, int b) -> { return a * b; };
		
      // 没有大括号及返回语句
      MathOperation division = (int a, int b) -> a / b;
		
      System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
      System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
      System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
      System.out.println("10 / 5 = " + tester.operate(10, 5, division));
		
      // 不用括号
      GreetingService greetService1 = message ->
      System.out.println("Hello " + message);
		
      // 用括号
      GreetingService greetService2 = (message) ->
      System.out.println("Hello " + message);
		
      greetService1.sayMessage("Runoob");
      greetService2.sayMessage("Google");
   }
	
   interface MathOperation {
      int operation(int a, int b);
   }
	
   interface GreetingService {
      void sayMessage(String message);
   }
	
   private int operate(int a, int b, MathOperation mathOperation){
      return mathOperation.operation(a, b);
   }
}
#+END_SRC
执行以上脚本，输出结果为：
$ javac Java8Tester.java 
$ java Java8Tester
10 + 5 = 15
10 - 5 = 5
10 x 5 = 50
10 / 5 = 2
Hello Runoob
Hello Google
- 使用 Lambda 表达式需要注意以下两点：
  1. Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的 Lambda 表达式来定义 MathOperation 接口的方法。然后我们定义了 sayMessage 的执行。
  2. Lambda 表达式免去了使用匿名方法的麻烦，并且给予 Java 简单但是强大的函数化的编程能力。
- 变量作用域
lambda 表达式只能引用 final 或 final 局部变量，这就是说不能在 lambda 内部修改定义在域外的变量，否则会编译错误。
在 Java8Tester.java 文件输入以下代码：
#+BEGIN_SRC java
public class Java8Tester {

   final static String salutation = "Hello! ";
   
   public static void main(String args[]){
      GreetingService greetService1 = message -> 
      System.out.println(salutation + message);
      greetService1.sayMessage("Runoob");
   }
	
   interface GreetingService {
      void sayMessage(String message);
   }
}
#+END_SRC
执行以上脚本，输出结果为：
$ javac Java8Tester.java 
$ java Java8Tester
Hello! Runoob

